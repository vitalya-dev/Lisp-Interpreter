struct __nt_context { int esp; int info; int prev; int handler; int stable; int sindex; int ebp; };
/*
** mpc - Micro Parser Combinator library for C
**
** https://github.com/orangeduck/mpc
**
** Daniel Holden - contact@daniel-holden.com
** Licensed under BSD3
*/

#ifndef mpc_h
#define mpc_h

#ifdef __cplusplus
#endif 

/* Copyright (C) 1986-2001 by Digital Mars. $Revision: 1.1.1.3 $ */
#if 0x857 || __RCC__
#pragma once
#endif

#ifndef __STDLIB_H
#define __STDLIB_H 1

#if __cplusplus
#endif 

/* Define _CRTAPI1 (for compatibility with the NT SDK) */
#ifndef _CRTAPI1
#define _CRTAPI1 __cdecl
#endif

/* Define _CRTAPI2 (for compatibility with the NT SDK) */
#ifndef _CRTAPI2
#define _CRTAPI2 __cdecl
#endif

/* Define CRTIMP */
#ifndef _CRTIMP
#if defined(_WIN32) && defined(_DLL)
#else
#define _CRTIMP
#endif
#endif

#if __OS2__ && 4 == 4
#else
#define __CLIB __cdecl
#endif

#define EXIT_SUCCESS   0
#define EXIT_FAILURE   1

#ifndef NULL
#ifdef __cplusplus
#else
#define NULL ((void *)0)
#endif
#endif

#if _M_AMD64
#else
typedef unsigned size_t;
#endif

//#ifndef __STDC__
#if !defined(_WCHAR_T_DEFINED)
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED 1
#endif
//#endif

#pragma pack(8)
typedef struct _DIV { int  quot,rem; } div_t;
typedef struct _LDIV { long quot,rem; } ldiv_t;
#if 4 == 4
typedef struct _LLDIV { long long quot,rem; } lldiv_t;
#endif
#pragma pack()

#if !__STDC__

#if !defined(ERANGE)
#define ERANGE 34
#endif

#define HUGE_VAL       __inf

#define RAND_MAX       32767

#define _div_t _DIV
#define _ldiv_t _LDIV

#ifdef __NT__
extern int __cdecl	__locale_mbsize;
#define MB_CUR_MAX	__locale_mbsize
#else
#endif 

#endif

#define _MAX_PATH   260
#define _MAX_DRIVE  3
#define _MAX_DIR    256
#define _MAX_FNAME  256
#define _MAX_EXT    256

#if defined(_MT) || __cplusplus
#else

#if !__STDC__
extern int __cdecl errno;
#endif
extern int __cdecl _doserrno;

#endif

double __cdecl atof(const char *);
#define _atold atof
int    __cdecl atoi(const char *);
long   __cdecl atol(const char *);
double __cdecl strtod(const char *,char **);
long double __cdecl strtold(const char *,char **);
long   __cdecl strtol(const char *,char **,int);
unsigned long  __cdecl strtoul(const char *,char **,int);
#if 4 == 4
long long   __cdecl atoll(const char *);
long long   __cdecl strtoll(const char *,char **,int);
unsigned long long __cdecl strtoull(const char *,char **,int);
#endif
int    __cdecl rand(void);
void   __cdecl srand(unsigned);
int    __cdecl random(int num);
void    __cdecl randomize(void);
 void * __cdecl calloc(size_t,size_t);
 void   __cdecl free(void *);
 void * __cdecl malloc(size_t);
 void * __cdecl realloc(void *,size_t);
void   __cdecl abort(void);
int    __cdecl atexit(void (*)(void));
void   __cdecl exit(int);
void   __cdecl _Exit(int);
void   __cdecl _exit(int);

#pragma noreturn (abort)
#pragma noreturn (_exit)
#pragma noreturn (_Exit)

 char * __cdecl getenv(const char *);
int    __cdecl system(const char *);
void * __cdecl bsearch(const void *,const void *,size_t,size_t,
       int (__cdecl *)(const void *,const void *));
void   __cdecl qsort(void *,size_t,size_t,
       int (__cdecl *)(const void *,const void *));
int    __cdecl abs(int);
long   __cdecl labs(long);
div_t  __cdecl div(int,int);
ldiv_t __cdecl ldiv(long,long);
#if 4 == 4
long long   __cdecl llabs(long long);
lldiv_t __cdecl lldiv(long long, long long);
#endif
int    __cdecl mblen(const char *, size_t);
size_t __cdecl _mbstrlen(const char *);
int    __cdecl mbtowc(wchar_t *, const char *, size_t);
int    __cdecl wctomb(char *, wchar_t);
size_t __cdecl mbstowcs(wchar_t *, const char *, size_t);
size_t __cdecl wcstombs(char *, const wchar_t *, size_t);
void   __cdecl perror(const char *);
#ifndef toupper
int    __cdecl toupper(int);
#endif
#ifndef tolower
int    __cdecl tolower(int);
#endif

unsigned       __cdecl _rotl(unsigned,int);
unsigned       __cdecl _rotr(unsigned,int);
unsigned long  __cdecl _lrotl(unsigned long,int);
unsigned long  __cdecl _lrotr(unsigned long,int);
char * __cdecl _fullpath(char *buf,const char *path,size_t buflen);

#if !__STDC__
#define fullpath       _fullpath
#endif

extern int __cdecl sys_nerr;
extern char * __cdecl sys_errlist[];
#define _sys_nerr sys_nerr
#define _sys_errlist sys_errlist

#ifndef __STDC__

#if 4 == 2
#else
int    __cdecl _fmblen(const char __far *,size_t);
int    __cdecl _fmbtowc(wchar_t __far *,const char __far *,size_t);
int    __cdecl _fwctomb(char __far *,wchar_t);
size_t __cdecl _fmbstowcs(wchar_t __far *, const char __far *, size_t);
size_t __cdecl _fwcstombs(char __far *, const wchar_t __far *, size_t);
unsigned long long __cdecl strtoull(const char *,char **,int);
#endif

#if 4 == 2
#else
extern char *__cdecl _pgmptr;
extern wchar_t *__cdecl _wpgmptr;
#endif

extern unsigned int __cdecl _osver;
#ifndef __NT__
#endif 

#ifdef _DLL
#else
extern int __cdecl __argc;
extern char __cdecl ** __argv;
extern wchar_t __cdecl ** __wargv;
#endif

#if defined (_WIN32)
wchar_t ** __cdecl __wparsecmdline(const wchar_t *, int *);
char ** __cdecl __parsecmdline(const char *, int *);
#endif

#if defined(_WINDOWS) || defined(__NT__)
extern unsigned char __cdecl _winmajor;
extern unsigned char __cdecl _winminor;
extern unsigned int __cdecl _winver;
#endif

#define _DOS_MODE 0
#define _OS2_MODE 1
#define _WIN_MODE 2

#if !__STDC__
#define DOS_MODE _DOS_MODE
#define OS2_MODE _OS2_MODE
#define WIN_MODE _WIN_MODE
#endif

extern unsigned char __cdecl _osmode;

#define _REAL_MODE 0
#define _PROT_MODE 1

extern unsigned char __cdecl _cpumode;

extern int __cdecl _fmode;

void __cdecl _splitpath(const char *, char *,char *, char *, char *);
void __cdecl _makepath(char *, const char *,const char *, const char *, const char *);
void __cdecl _searchenv(const char *filename, const char *varname, char *pathname);

#define	_HEAPEMPTY	-1
#define	_HEAPOK		-2
#define	_HEAPBADBEGIN	-3
#define	_HEAPBADNODE	-4
#define	_HEAPEND	-5
#define	_HEAPBADPTR	-6


 int __cdecl _heapchk(void);
 int __cdecl _heapset(unsigned);
#if 4 == 2
#else
int __cdecl _heapadd(void *,size_t);
#endif
int __cdecl _heapmin(void);

#ifdef __NT__
#define _expand realloc
#else
#endif 

 size_t __cdecl _msize(void *);

#if __LARGE__ || __COMPACT__
#else
void * __cdecl _nmalloc(size_t);
void * __cdecl _ncalloc(size_t,size_t);
void * __cdecl _nrealloc(void *,size_t);
void __cdecl _nfree(void *);
size_t __cdecl _nmsize(void *);
size_t __cdecl _memmax(void);
size_t __cdecl _memavl(void);
unsigned int __cdecl _freect(size_t);
unsigned __cdecl coreleft(void);
unsigned long __cdecl farcoreleft(void);
#if 4 == 2 || (!1 && !__OS2__)
#endif 
#endif

#if 4 == 2
#endif 

char * __cdecl itoa(int,char *,int);
char * __cdecl _itoa(int, char *,int);
char * __cdecl ltoa(long, char *, int);
char * __cdecl _ltoa(long, char *,int);
char *  __cdecl ultoa(unsigned long, char *, int);
char * __cdecl ecvt(double,int,int *,int *);
char * __cdecl fcvt(double,int,int *,int *);
char * __cdecl _fcvt(double,int,int *,int *);
char * __cdecl gcvt(double,int,char *);
void * __cdecl sbrk(size_t);
void   __cdecl swab(char *,char *,size_t);
float  __cdecl strtof(const char *,char **);
#define _swab swab
#define _ecvt ecvt
#define _gcvt gcvt
#if !1
#endif 
#define _strtold       strtold
#define _ultoa ultoa
#if _MSDOS
#else
void *    __cdecl alloca(size_t);
#endif
#define _alloca alloca
size_t __cdecl stackavail(void);
size_t __cdecl _chkstack(void);
#define _stackavail stackavail

#if 4 == 4
int __cdecl _fatexit (void (__cdecl *func)(void));
typedef void (__cdecl * _fonexit_t)(void);
_fonexit_t __cdecl _fonexit (_fonexit_t func);
#else
#endif 

typedef void (__cdecl * _onexit_t)(void);
_onexit_t __cdecl _onexit (_onexit_t func);

#ifndef __STDC__
#define onexit _onexit
#endif

#if 4 == 2
#endif 
 int            __cdecl putenv(const char *);

#define _putenv putenv

/* Min and Max macros useful in both C and CPP */
#define __max(a,b)            (((a) > (b)) ? (a) : (b))
#define __min(a,b)            (((a) < (b)) ? (a) : (b))


#ifndef __cplusplus

#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif
#endif

extern int (__far __cdecl *_malloc_handler)(void);
extern char * __cdecl _envptr;
#ifdef _DLL
#else
extern char ** __cdecl _environ;
#endif

#define environ _environ

#ifdef __NT__
#define _aenvptr _envptr
extern wchar_t * __cdecl _wenvptr;
#ifdef _DLL
#else
extern wchar_t ** __cdecl _wenviron;
#endif

#define wenviron _wenviron
#endif

#if !(defined (_WINDOWS) || defined (__NT__) || defined (DOS386))
#endif 

#if M_UNIX || M_XENIX
#endif 

#endif

#ifdef __NT__
#ifndef __STDC__
int __cdecl _wtoi(const wchar_t *);
long __cdecl _wtol(const wchar_t *);
//double __CLIB wcstod(const wchar_t *, wchar_t **);
//long double __CLIB wcstold(const wchar_t *, wchar_t **);
//long __CLIB wcstol(const wchar_t *, wchar_t **, int);
//unsigned long __CLIB wcstoul(const wchar_t *, wchar_t **, int);
//long long __CLIB wcstoll(const wchar_t *, wchar_t **, int);
//unsigned long long __CLIB wcstoull(const wchar_t *, wchar_t **, int);
 wchar_t * __cdecl _wgetenv(const wchar_t *);
int __cdecl _wsystem(const wchar_t *);
wchar_t * __cdecl _itow(int, wchar_t *, int);
wchar_t * __cdecl _ltow(long, wchar_t *, int);
wchar_t * __cdecl _ultow(unsigned long, wchar_t *, int);
wchar_t * __cdecl _wfullpath(wchar_t *, const wchar_t *, size_t);
void __cdecl _wmakepath(wchar_t *, const wchar_t *, const wchar_t *, const wchar_t *, const wchar_t *);
void __cdecl _wperror(const wchar_t *);
 int __cdecl _wputenv(const wchar_t *);
void __cdecl _wsearchenv(const wchar_t *, const wchar_t *, wchar_t *);
void __cdecl _wsplitpath(const wchar_t *, wchar_t *, wchar_t *, wchar_t *, wchar_t *);
#define itow _itow
#define ltow _ltow
#define ultow _ultow
#endif
#endif

#if __cplusplus
#endif 

#endif

/* Copyright (C) 1986-2001 by Digital Mars. $Revision: 1.1.1.2 $ */
#if 0x857 || __RCC__
#pragma once
#endif

#ifndef __STDIO_H
#define __STDIO_H 1

#if __cplusplus
#endif 

/* Define _CRTAPI1 (for compatibility with the NT SDK) */
#ifndef _CRTAPI1
#endif 


/* Define _CRTAPI2 (for compatibility with the NT SDK) */
#ifndef _CRTAPI2
#endif 

/* Define CRTIMP */
#ifndef _CRTIMP
#endif 

#if __OS2__ && 4 == 4
#else
#define __CLIB	__cdecl
#endif

#if M_UNIX || M_XENIX || 1
#define _NFILE	60
#else
#endif 


#define SEEK_SET	0
#define SEEK_CUR	1
#define SEEK_END	2

#ifndef NULL
#endif 

#if __cplusplus
#else
#define __RESTRICT restrict
#endif

#if M_UNIX || M_XENIX
#elif 4 == 4
#define BUFSIZ		0x4000
#else
#endif 

#if 4 == 2 && (1 || __MEDIUM__)
#endif 

#if _M_AMD64
#else
typedef unsigned size_t;
#endif

#ifndef __STDC__

#if !defined(_WCHAR_T_DEFINED)
#endif 

typedef wchar_t wint_t;
typedef wchar_t wctype_t;
#endif

#define EOF (-1)

#ifndef __STDC__
#define WEOF (wint_t) (0xFFFF)
#endif

#ifndef __FILE_DEFINED
#pragma pack(1)
#define __FILE_DEFINED 1
typedef struct _iobuf
{
#if M_UNIX || M_XENIX
#elif __OS2__ && 4 == 4
#elif 1
	char	*_ptr;
	int	_cnt;
	char	*_base;
	int	_flag;
	int	_file;
	int	_charbuf;
	int	_bufsiz;
	int	__tmpnum;
#define _bufsize(f) ((f)->_bufsiz)
#else
#endif 
} FILE;
#pragma pack()
#endif

#define _F_RDWR 0x0003
#define _F_READ 0x0001
#define _F_WRIT 0x0002
#define _F_BUF  0x0004
#define _F_LBUF 0x0008
#define _F_ERR  0x0010
#define _F_EOF  0x0020
#define _F_BIN  0x0040
#define _F_IN   0x0080
#define _F_OUT  0x0100
#define _F_TERM 0x0200

#ifdef M_ELF
#endif 

#if defined (_DLL)
#else

extern	FILE __cdecl _iob[60];

#endif

#define _IOREAD		1
#define _IOWRT		2
#define _IONBF		4
#define _IOMYBUF	8
#define _IOEOF		0x10
#define _IOERR		0x20
#define _IOLBF		0x40
#define _IOSTRG         0x40
#define _IORW		0x80
#define _IOFBF		0
#define _IOAPP		0x200
#if M_UNIX || M_XENIX
#else
#define _IOTRAN		0x100
#ifdef	BIGBUF
#endif 
#endif

#define stdin	(&_iob[0])
#define stdout	(&_iob[1])
#define stderr	(&_iob[2])

#if M_UNIX || M_XENIX
#else
#ifndef __STDC__
#ifndef __NT__
#endif 
#endif
#define FOPEN_MAX	20
#if defined(_WIN32)
#define FILENAME_MAX 256  /* 255 plus NULL */
#else
#endif 
#endif

#if M_UNIX || M_XENIX
#else
#define _P_tmpdir	"\\"
#define _wP_tmpdir	L"\\"
#endif
#define P_tmpdir	_P_tmpdir
#define wP_tmpdir	_wP_tmpdir
#if !defined(_WIN32)
#else
#define L_tmpnam    sizeof(_P_tmpdir)+12
#endif
#define TMP_MAX		32767
#define _SYS_OPEN       20
#define SYS_OPEN        _SYS_OPEN

typedef long fpos_t;

typedef char *va_list;

int	__cdecl fwide(FILE *stream, int mode);
char *	__cdecl tmpnam(char *);
FILE *	__cdecl fopen(const char *,const char *);
FILE *	__cdecl _fsopen(const char *,const char *,int );
FILE *	__cdecl freopen(const char *,const char *,FILE *);
int	__cdecl fseek(FILE *,long,int);
long	__cdecl ftell(FILE *);
char *	__cdecl fgets(char *,int,FILE *);
int	__cdecl fgetc(FILE *);
int   __cdecl _fgetchar(void);
int	__cdecl fflush(FILE *);
int	__cdecl fclose(FILE *);
int	__cdecl fputs(const char *,FILE *);
int	__cdecl getc(FILE *);
int	__cdecl getchar(void);
char *	__cdecl gets(char *);
int	__cdecl fputc(int,FILE *);
int   __cdecl _fputchar(int);
int	__cdecl putc(int,FILE *);
int	__cdecl putchar(int);
int	__cdecl puts(const char *);
int	__cdecl ungetc(int,FILE *);
size_t	__cdecl fread(void *,size_t,size_t,FILE *);
size_t	__cdecl fwrite(const void *,size_t,size_t,FILE *);
int	__cdecl printf(const char *,...);
int	__cdecl fprintf(FILE *,const char *,...);
int	__cdecl  vfprintf(FILE *,const char *,va_list);
int	__cdecl  vprintf(const char *,va_list);
int	__cdecl sprintf(char *,const char *,...);
int	__cdecl  vsprintf(char *,const char *,va_list);
int	__cdecl scanf(const char *,...);
int	__cdecl fscanf(FILE *,const char *,...);
int	__cdecl sscanf(const char *,const char *,...);
int	__cdecl vsnprintf(char * restrict,size_t,const char * restrict,va_list);
int	__cdecl vscanf(const char * restrict, va_list);
int	__cdecl vfscanf(FILE * restrict, const char * restrict, va_list);
int	__cdecl vsscanf(const char * restrict, const char * restrict, va_list);
void	__cdecl setbuf(FILE *,char *);
int	__cdecl setvbuf(FILE *,char *,int,size_t);
int	__cdecl remove(const char *);
int	__cdecl rename(const char *,const char *);
void	__cdecl rewind(FILE *);
void	__cdecl clearerr(FILE *);
int	__cdecl feof(FILE *);
int	__cdecl ferror(FILE *);
void	__cdecl perror(const char *);
int	__cdecl fgetpos(FILE *,fpos_t *);
int	__cdecl fsetpos(FILE *,const fpos_t *);
FILE *	__cdecl tmpfile(void);
int	__cdecl _rmtmp(void);
int     __cdecl _fillbuf(FILE *);
int     __cdecl _flushbu(int, FILE *);
/*#define _filbuf _fillbuf*/
/*#define _flsbuf _flushbu*/

int __cdecl getw(FILE *FHdl);
#define _getw  getw
int __cdecl putw(int Word, FILE *FilePtr);
#define _putw putw

#if __cplusplus
#else
#define getchar()	getc(stdin)
#define putchar(c)      putc(c,stdout)

#if !defined(_WINDOWS)
int __cdecl putch(int);
#define _putch          putch
#endif

#define getc(fp)	fgetc(fp)
#define putc(c,fp)	fputc((c),(fp))
#define ferror(fp)	((fp)->_flag&_IOERR)
#define feof(fp)	((fp)->_flag&_IOEOF)
#define clearerr(fp)	((void)((fp)->_flag&=~(_IOERR|_IOEOF)))
#define rewind(fp)	((void)(fseek(fp,0L,SEEK_SET),((fp)->_flag&=~_IOERR)))
#endif

#ifndef __STDC__
#define fileno(fp)	((fp)->_file)
#define _fileno(fp)     ((fp)->_file)

#if M_UNIX || M_XENIX
#endif 

int     __cdecl unlink(const char *);
#define _unlink unlink

FILE *	__cdecl fdopen(int, const char *);
int   __cdecl fgetchar(void);
int   __cdecl fputchar(int);
int	__cdecl fcloseall(void);
long	__cdecl filesize(const char *);
int	__cdecl flushall(void);
int	__cdecl getch(void);
int	__cdecl getche(void);
int     __cdecl kbhit(void);
char *  __cdecl tempnam (char *dir, char *pfx);
int     __cdecl _snprintf(char *,size_t,const char *,...);
int	__cdecl _vsnprintf(char *,size_t,const char *,va_list);
#define _flushall flushall
#define _fcloseall fcloseall
#define _fdopen fdopen
#define _tempnam tempnam
#define _getche getche
#define _getch getch
#endif

#ifdef __NT__
#ifndef __STDC__
wchar_t * __cdecl _wtmpnam(wchar_t *);
FILE * __cdecl _wfopen(const wchar_t *, const wchar_t *);
FILE * __cdecl _wfsopen(const wchar_t *, const wchar_t *, int);
FILE * __cdecl _wfreopen(const wchar_t *, const wchar_t *, FILE *);
wchar_t * __cdecl fgetws(wchar_t *, int, FILE *);
int __cdecl fputws(const wchar_t *, FILE *);
wchar_t * __cdecl _getws(wchar_t *);
int __cdecl _putws(const wchar_t *);
int __cdecl wprintf(const wchar_t * restrict format, ...);
int __cdecl fwprintf(FILE * restrict stream, const wchar_t * restrict format, ...);
int __cdecl vwprintf(const wchar_t * restrict format, va_list arg);
int __cdecl vfwprintf(FILE * restrict stream, const wchar_t * restrict format, va_list arg);
int __cdecl swprintf(wchar_t * restrict s, size_t n, const wchar_t * restrict format, ...);
int __cdecl _swprintf(wchar_t * restrict s, const wchar_t * restrict format, ...);
int __cdecl _snwprintf(wchar_t *, size_t, const wchar_t *, ...);
int __cdecl vswprintf(wchar_t * restrict s, size_t n, const wchar_t * restrict format, va_list arg);
int __cdecl _vswprintf(wchar_t * restrict s, const wchar_t * restrict format, va_list arg);
int __cdecl _vsnwprintf(wchar_t *, size_t, const wchar_t *, va_list);
int __cdecl wscanf(const wchar_t * restrict format, ...);
int __cdecl fwscanf(FILE * restrict stream, const wchar_t * restrict format, ...);
int __cdecl swscanf(const wchar_t * restrict s, const wchar_t * restrict format, ...);
int __cdecl _wremove(const wchar_t *);
void __cdecl _wperror(const wchar_t *);
FILE * __cdecl _wfdopen(int, const wchar_t *);
wchar_t * __cdecl _wtempnam(wchar_t *, wchar_t *);
#if M_UNIX || M_XENIX
#endif 
wint_t __cdecl fgetwc(FILE *);
wint_t __cdecl _fgetwchar(void);
wint_t __cdecl fputwc(wint_t, FILE *);
wint_t __cdecl _fputwchar(wint_t);
wint_t __cdecl getwc(FILE *);
wint_t __cdecl getwchar(void);
wint_t __cdecl putwc(wint_t, FILE *);
wint_t __cdecl putwchar(wint_t);
wint_t __cdecl ungetwc(wint_t, FILE *);
#define getwchar()	fgetwc(stdin)
#define putwchar(_c)	fputwc((_c),stdout)
#define getwc(_stm)	fgetwc(_stm)
#define putwc(_c,_stm)	fputwc(_c,_stm)
#endif
#endif

#if __cplusplus
#endif 

#endif

/* Copyright (C) 1986-2005 by Digital Mars */
/* www.digitalmars.com */

#if 0x857 || __RCC__
#pragma once
#endif

#ifndef __STDARG_H
#define __STDARG_H 1

#if 4 == 4
#define __VA_ALIGN	3
#else
#endif 

#define __va_size(type) ((sizeof(type) + __VA_ALIGN) & ~__VA_ALIGN)
#define _INTSIZEOF(n)    ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#if 1
#define __SS
#define _FARARG_
#else
#endif 

typedef char  *va_list;

#if __cplusplus
#else
    #define va_start(ap,parmn) ((void)((ap) = (va_list)&(parmn)+__va_size(parmn)))
    #define va_end(ap)  ((void)0)
#endif

#define va_arg(ap,type)	   (*(type __SS *)(((ap)+=__va_size(type))-(__va_size(type))))
#define va_copy(dest,src)  ((dest) = (src))

#endif


// Copyright (C) 1986-2001 by Digital Mars.
// www.digitalmars.com

#if 0x857 || __RCC__
#pragma once
#endif

#ifndef __STRING_H
#define __STRING_H 1

#if __cplusplus
#endif 

/* Define _CRTAPI1 (for compatibility with the NT SDK) */
#ifndef _CRTAPI1
#endif 

/* Define _CRTAPI2 (for compatibility with the NT SDK) */
#ifndef _CRTAPI2
#endif 

/* Define CRTIMP */
#ifndef _CRTIMP
#endif 

#if _M_AMD64
#else
typedef unsigned size_t;
#endif

#ifndef __STDC__
#if !defined(_WCHAR_T_DEFINED)
#endif 
#endif

#define _NLSCMPERROR	2147483647

#ifndef NULL
#endif 

#if __cplusplus
#else
#define __RESTRICT restrict
#endif

#if __OS2__ && 4 == 4
#else
#define __CLIB	__cdecl
#endif

void *	__cdecl memcpy(void *,const void *,size_t);
void *  __cdecl _inline_memcpy(void *,const void *,size_t);
void *	__cdecl memmove(void *,const void *,size_t);
char *	__cdecl strcpy(char *,const char *);
char *	__cdecl _inline_strcpy(char *,const char *);
char *	__cdecl strncpy(char *,const char *,size_t);
char *	__cdecl strcat(char *,const char *);
char *	__cdecl strncat(char *,const char *,size_t);
int	__cdecl memcmp(const void *,const void *,size_t);
int     __cdecl _inline_memcmp(const void *,const void *,size_t);
int	__cdecl strcmp(const char *,const char *);
int	__cdecl _inline_strcmp(const char *,const char *);
int	__cdecl strcoll(const char *,const char *);
int	__cdecl strncmp(const char *,const char *,size_t);
size_t	__cdecl strxfrm(char *,const char *,size_t);
size_t	__cdecl strcspn(const char *,const char *);
size_t	__cdecl strspn(const char *,const char *);
char *	__cdecl strtok(char *,const char *);
void *	__cdecl memset(void *,int,size_t);
char *	__cdecl strerror(int);
size_t	__cdecl strlen(const char *);
size_t	__cdecl _inline_strlen(const char *);

#ifndef __STDC__
/* Unicode string routines, these are in wchar.h as well */
size_t __cdecl wcslen(const wchar_t *);
 wchar_t * __cdecl wcscpy(wchar_t *, const wchar_t *);
#ifdef __NT__
wchar_t * __cdecl wmemcpy(wchar_t *,const wchar_t *,size_t);
wchar_t * __cdecl wmemmove(wchar_t *,const wchar_t *,size_t);
wchar_t * __cdecl wmemset(wchar_t *,wchar_t,size_t);
wchar_t * __cdecl wcsncpy(wchar_t *, const wchar_t *, size_t);
wchar_t * __cdecl wcscat(wchar_t *, const wchar_t *);
wchar_t * __cdecl wcsncat(wchar_t *, const wchar_t *, size_t);
int __cdecl wcscmp(const wchar_t *, const wchar_t *);
int __cdecl wcsncmp(const wchar_t *, const wchar_t *, size_t);
int __cdecl wcscoll(const wchar_t *, const wchar_t *);
size_t __cdecl wcsxfrm(wchar_t *, const wchar_t *, size_t);
size_t __cdecl wcscspn(const wchar_t *, const wchar_t *);
size_t __cdecl wcsspn(const wchar_t *, const wchar_t *);
wchar_t * __cdecl wcstok(wchar_t * restrict s1, const wchar_t * restrict s2, wchar_t ** restrict ptr);
int __cdecl _wcsicoll(const wchar_t *, const wchar_t *);
int __cdecl _wcsncoll(const wchar_t *, const wchar_t *, size_t);
int __cdecl _wcsnicoll(const wchar_t *, const wchar_t *, size_t);
int __cdecl _wcsicmp(const wchar_t *, const wchar_t *);
 int __cdecl _wcsnicmp(const wchar_t *, const wchar_t *, size_t);
 wchar_t * __cdecl _wcsdup(const wchar_t *);
wchar_t * __cdecl _wcslwr(wchar_t *);
wchar_t * __cdecl _wcsupr(wchar_t *);
wchar_t * __cdecl _wcsnset(wchar_t *, wchar_t, size_t);
wchar_t * __cdecl _wcsrev(wchar_t *);
wchar_t * __cdecl _wcsset(wchar_t *, wchar_t);
#define wcswcs	wcsstr
#define wcsdup	_wcsdup
#define wcsicmp	_wcsicmp
#define wcsnicmp _wcsnicmp
#define wcsnset	_wcsnset
#define wcsrev	_wcsrev
#define wcsset	_wcsset
#define wcslwr	_wcslwr
#define wcsupr	_wcsupr
#define wcsicoll _wcsicoll
#endif
#endif

int  *	__cdecl _memintset(int *, int, size_t);
int	__cdecl memicmp(const void *,const void *,size_t);
void *  __cdecl memccpy(void *,const void *,int,unsigned int);
char *	__cdecl stpcpy(char *,const char *);
int	__cdecl stricmp(const char *,const char *);
int	__cdecl strcmpl(const char *,const char *); /* obsolete */
int	__cdecl strnicmp(const char *, const char *, size_t);
char *	__cdecl strdup(const char *);
char *	__cdecl strlwr(char *);
char *	__cdecl strupr(char *);
char *	__cdecl strnset(char *,int,size_t);
char *	__cdecl strrev(char *);
char *	__cdecl strset(char *,int);
void	__cdecl swab(char *,char *,size_t);
void	__cdecl movedata(unsigned short srcseg,unsigned srcoff,unsigned short destseg,unsigned destoff,size_t nbytes);
char *	__cdecl _strerror(const char *);
int	__cdecl _stricoll(const char *, const char *);
int	__cdecl _strncoll(const char *, const char *, size_t);
int	__cdecl _strnicoll(const char *, const char *, size_t);

#if 4 == 2
#endif 

#ifndef __NT__
#endif 

#define strncmpl        strnicmp

#if !__STDC__
#define _stricmp stricmp
#define strcmpi stricmp
#define _strcmpi stricmp
#define movmem(src,dest,len) ((void)memmove(dest,src,len))
#define setmem(dest,len,chr) ((void)memset(dest,chr,len))
#define strncmpi strnicmp
#define _strnicmp strnicmp
#define _movedata movedata
int	__cdecl _memicmp(const void *,const void *,size_t);
#define _memccpy memccpy
char *	__cdecl _strdup(const char *);
#define _strlwr strlwr
#define _strnset strnset
char *	__cdecl _strrev(char *);
#define _strset strset
#define _strupr strupr
#define _swab swab

#if 4 == 2
#endif 
#endif

#if !__STDC__
extern int __cdecl sys_nerr;
extern char * __cdecl sys_errlist[];
#endif

#if __cplusplus
#endif 

#if 199901L >= 199901L

char *	__cdecl strchr(const char *,int);
char *	__cdecl strrchr(const char *,int);
char *	__cdecl strpbrk(const char *,const char *);
char *	__cdecl strstr(const char *,const char *);
void *	__cdecl memchr(const void *,int,size_t);

#ifndef __STDC__
 wchar_t * __cdecl wcschr(const wchar_t *, wchar_t);
wchar_t * __cdecl wcsrchr(const wchar_t *, wchar_t);
wchar_t * __cdecl wcspbrk(const wchar_t *, const wchar_t *);
wchar_t * __cdecl wcsstr(const wchar_t *, const wchar_t *);
wchar_t * __cdecl wmemchr(const wchar_t *,wchar_t,size_t);
#endif

#elif __cplusplus
#endif 

#endif


/* Copyright (C) 1986-2003 by Digital Mars.
 * All Rights Reserved
 * www.digitalmars.com
 */

#if 0x857 || __RCC__
#pragma once
#endif

#ifndef __MATH_H
#define __MATH_H 1

#if __cplusplus
#endif 

/* Define _CRTAPI1 (for compatibility with the NT SDK) */
#ifndef _CRTAPI1
#endif 

/* Define _CRTAPI2 (for compatibility with the NT SDK) */
#ifndef _CRTAPI2
#endif 

/* Define CRTIMP */
#ifndef _CRTIMP
#endif 

typedef long double float_t;
typedef long double double_t;

#define HUGE_VAL	__inf
#define HUGE_VALF	((float)__inf)
#define HUGE_VALL	((long double)__inf)

#define INFINITY	__inf
#define	NAN		__nan

#ifndef __STDC__
#define NANS		__nans
#endif

#define	FP_NANS		0
#define FP_NANQ		1
#define	FP_INFINITE	2
#define	FP_NORMAL	3
#define	FP_SUBNORMAL	4
#define	FP_ZERO		5

#define FP_NAN		FP_NANQ
#define FP_EMPTY	6
#define FP_UNSUPPORTED	7

#if 4 == 2
#else
#define FP_ILOGB0	(-2147483647L - 1)
#define FP_ILOGBNAN	(-2147483647L - 1)
#endif

#define MATH_ERRNO	1
#define MATH_ERREXCEPT	2
#define math_errhandling (MATH_ERRNO | MATH_ERREXCEPT)

unsigned __cdecl __fpclassify_f(float);
unsigned __cdecl __fpclassify_d(double);
unsigned __cdecl __fpclassify_ld(long double);

unsigned __cdecl __fpxam_ld(long double);

#if __cplusplus
#else
#define fpclassify(fe)	(sizeof(fe) == sizeof(float) ?						    __fpclassify_f(fe) :						    (sizeof(fe) == sizeof(double) ? __fpclassify_d(fe) : __fpclassify_ld(fe)) 			)
#if 1
#define signbit __signbit
__inline int __signbit(long double fe)
	{ return (sizeof(long double) == sizeof(double))
		? ((short *)&(fe))[3] & 0x8000
		: ((short *)&(fe))[4] & 0x8000;
	}
#else
#endif 
#define isfinite(fe)	(fpclassify(fe) >= FP_NORMAL)
#define isnormal(fe)	(fpclassify(fe) == FP_NORMAL)
#define isnan(fe)	(fpclassify(fe) <= FP_NANQ)
#define isinf(fe)	(fpclassify(fe) == FP_INFINITE)
#endif


#if __OS2__ && 4 == 4
#else
#define __CLIB	__cdecl
#endif

double	__cdecl acos(double);
float	__cdecl acosf(float);
long double __cdecl acosl(long double);

double	__cdecl asin(double);
float	__cdecl asinf(float);
long double __cdecl asinl(long double);

double	__cdecl atan(double);
float	__cdecl atanf(float);
long double __cdecl atanl(long double);

double	__cdecl atan2(double,double);
float	__cdecl atan2f(float,float);
long double __cdecl atan2l(long double, long double);

float		__cdecl cosf(float);
#if !(1 && 6 >= 3)
#endif 
long double	__cdecl cosl(long double);
float		__cdecl _inline_cosf(float);
double		__cdecl _inline_cos(double);
long double	__cdecl _inline_cosl(long double);
#if 1 && 6 >= 3
#if __cplusplus
#else
#define cos(d)  _inline_cos(d)
#endif
#define cosf(f) _inline_cosf(f)
#define cosl(d) _inline_cosl(d)
#elif !_WIN32
#endif 
//#define _cosl	cosl

float		__cdecl sinf(float);
#if !(1 && 6 >= 3)
#endif 
long double	__cdecl sinl(long double);
float		__cdecl _inline_sinf(float);
double		__cdecl _inline_sin(double);
long double	__cdecl _inline_sinl(long double);
#if 1 && 6 >= 3
#if __cplusplus
#else
#define sin(d)  _inline_sin(d)
#endif
#define sinf(f) _inline_sinf(f)
#define sinl(d) _inline_sinl(d)
#elif !_WIN32
#endif 

double	__cdecl tan(double);
float	__cdecl tanf(float);
long double __cdecl tanl(long double);

double __cdecl acosh(double x);
float __cdecl acoshf(float x);
long double __cdecl acoshl(long double x);

double __cdecl asinh(double x);
float __cdecl asinhf(float x);
long double __cdecl asinhl(long double x);

double __cdecl atanh(double x);
float __cdecl atanhf(float x);
long double __cdecl atanhl(long double x);


double	__cdecl cosh(double);
float	__cdecl coshf(float);
long double __cdecl coshl(long double);

double	__cdecl sinh(double);
float	__cdecl sinhf(float);
long double __cdecl sinhl(long double);

double	__cdecl tanh(double);
float	__cdecl tanhf(float);
long double __cdecl tanhl(long double);

double	__cdecl exp(double);
float	__cdecl expf(float);
long double __cdecl expl(long double);

double	__cdecl exp2(double);
float	__cdecl exp2f(float);
long double __cdecl exp2l(long double);

double	__cdecl expm1(double);
float	__cdecl expm1f(float);
long double __cdecl expm1l(long double);

double	__cdecl frexp(double,int *);
float	__cdecl frexpf(float,int *);
#if 1
long double __cdecl frexpl(long double,int *);
#else
#endif 

int __cdecl ilogb(double);
int __cdecl ilogbf(float);
int __cdecl ilogbl(long double);

double	__cdecl ldexp(double,int);
float	__cdecl ldexpf(float,int);
double	__cdecl _inline_ldexp(double,int);
float	__cdecl _inline_ldexpf(float,int);
#if 1
long double	__cdecl ldexpl(long double, int);
long double	__cdecl _inline_ldexpl(long double, int);
#else
#endif 
#if 1 && 6 >= 3
#define ldexp(d,i)  _inline_ldexp(d,i)
#define ldexpf(f,i) _inline_ldexpf(f,i)
#define ldexpl(d,i) _inline_ldexpl(d,i)
#endif

#if 1
long double __cdecl _inline_yl2x(long double x, long double y);
long double __cdecl _inline_yl2xp1(long double x, long double y);
#endif

double	__cdecl log(double);
float	__cdecl logf(float);
long double __cdecl logl(long double);

double	__cdecl log10(double);
float	__cdecl log10f(float);
long double __cdecl log10l(long double);

double	__cdecl log1p(double);
float	__cdecl log1pf(float);
#if 1
long double	__cdecl log1pl(long double);
#else
#endif 

double	__cdecl log2(double);
float	__cdecl log2f(float);
long double __cdecl log2l(long double);

double	__cdecl logb(double);
float	__cdecl logbf(float);
#if 1
long double __cdecl logbl(long double);
#else
#endif 

double	__cdecl modf(double,double *);
float	__cdecl modff(float,float *);
long double __cdecl modfl(long double, long double *);

double	__cdecl scalbn(double, int);
float	__cdecl scalbnf(float, int);
long double __cdecl scalbnl(long double, int);

double	__cdecl scalbln(double, long);
float	__cdecl scalblnf(float, long);
long double __cdecl scalblnl(long double, long);

double	__cdecl cbrt(double);
float	__cdecl cbrtf(float);
long double __cdecl cbrtl(long double);

float		__cdecl fabsf(float);
long double	__cdecl fabsl(long double);
float		__cdecl _inline_fabsf(float);
double		__cdecl _inline_fabs(double);
long double	__cdecl _inline_fabsl(long double);
#if __cplusplus
#else
double		__cdecl fabs(double);
#define fabs(d)  _inline_fabs(d)
#endif
#define fabsf(f) _inline_fabsf(f)
#define fabsl(d) _inline_fabsl(d)

float	__cdecl hypotf(float, float);
double	__cdecl hypot(double,double);
long double __cdecl hypotl(long double, long double);

double	__cdecl pow(double,double);
float	__cdecl powf(float,float);
long double __cdecl powl(long double, long double);

float		__cdecl sqrtf(float);
#if !1 && !__cplusplus
#endif 
long double	__cdecl sqrtl(long double);
float		__cdecl _inline_sqrtf(float);
double		__cdecl _inline_sqrt(double);
long double	__cdecl _inline_sqrtl(long double);
#if 1
#if __cplusplus
#else
#define sqrt(d)  _inline_sqrt(d)
#endif
#define sqrtf(f) _inline_sqrtf(f)
#define sqrtl(d) _inline_sqrtl(d)
#elif !_WIN32
#endif 


double __cdecl erf(double x);
float __cdecl erff(float x);
long double __cdecl erfl(long double x);

double __cdecl erfc(double x);
float __cdecl erfcf(float x);
long double __cdecl erfcl(long double x);

double __cdecl lgamma(double x);
float __cdecl lgammaf(float x);
long double __cdecl lgammal(long double x);

double __cdecl tgamma(double x);
float __cdecl tgammaf(float x);
long double __cdecl tgammal(long double x);

float		__cdecl ceilf(float);
double		__cdecl ceil(double);
long double	__cdecl ceill(long double);

float		__cdecl floorf(float);
double		__cdecl floor(double);
long double	__cdecl floorl(long double);

double __cdecl nearbyint(double);
float __cdecl nearbyintf(float);
long double __cdecl nearbyintl(long double);
#if !1
#endif 

float		__cdecl rintf(float);
double		__cdecl rint(double);
long double	__cdecl rintl(long double);
float		__cdecl _inline_rintf(float);
double		__cdecl _inline_rint(double);
long double	__cdecl _inline_rintl(long double);
#if 1
#define rint(d)  _inline_rint(d)
#define rintf(f) _inline_rintf(f)
#define rintl(d) _inline_rintl(d)
#elif !_WIN32
#endif 

long int __cdecl lrint(double x);
long int __cdecl lrintf(float x);
long int __cdecl lrintl(long double x);

#if 1
long long int __cdecl llrint(double x);
long long int __cdecl llrintf(float x);
long long int __cdecl llrintl(long double x);
#endif

double __cdecl round(double );
float __cdecl roundf(float );
long double __cdecl roundl(long double );
#if !1
#endif 

long int __cdecl lround(double x);
long int __cdecl lroundf(float x);
long int __cdecl lroundl(long double x);

#if 1
long long int __cdecl llround(double x);
long long int __cdecl llroundf(float x);
long long int __cdecl llroundl(long double x);
#endif

double __cdecl trunc(double);
float __cdecl truncf(float);
long double __cdecl truncl(long double);
#if !1
#endif 

double	__cdecl fmod(double,double);
float	__cdecl fmodf(float,float);
long double __cdecl fmodl(long double, long double);

double __cdecl remainder(double, double);
float __cdecl remainderf(float, float);
long double __cdecl remainderl(long double, long double);

double __cdecl remquo(double, double, int *);
float __cdecl remquof(float, float, int *);
long double __cdecl remquol(long double, long double, int *);
#define remquol		remquo

double		__cdecl copysign(double, double);
float		__cdecl copysignf(float, float);
long double	__cdecl copysignl(long double, long double);
#if !1
#endif 

double __cdecl nan(const char *);
float __cdecl nanf(const char *);
long double __cdecl nanl(const char *);
#if !1
#endif 

double __cdecl nextafter(double, double);
float __cdecl nextafterf(float, float);
long double __cdecl nextafterl(long double, long double);
#define nextafterl	(long double)nextafter

double __cdecl nexttoward(double, double);
float __cdecl nexttowardf(float, float);
long double __cdecl nexttowardl(long double, long double);

double __cdecl fdim(double, double);
float __cdecl fdimf(float, float);
long double __cdecl fdiml(long double, long double);

double __cdecl fmax(double, double);
float __cdecl fmaxf(float, float);
long double __cdecl fmaxl(long double, long double);

double __cdecl fmin(double, double);
float __cdecl fminf(float, float);
long double __cdecl fminl(long double, long double);

double __cdecl fma(double, double, double);
float __cdecl fmaf(float, float, float);
long double __cdecl fmal(long double, long double, long double);


#define isgreater(x,y)		!((x) !>  (y))
#define isgreaterequal(x,y)	!((x) !>= (y))
#define isless(x,y)		!((x) !<  (y))
#define islessequal(x,y)	!((x) !<= (y))
#define islessgreater(x,y)	!((x) !<> (y))
#define isunordered(x,y)	((x) !<>= (y))

#ifndef __STDC__

#define _matherrl _matherr

#if 0 // obsolete
#endif 

#define M_LOG2T		3.32192809488736234787
#define M_LOG2		0.30102999566398119521
#define	M_LOG2E		1.4426950408889634074
#define	M_LN2		0.6931471805599453094172321
#define	M_PI		3.14159265358979323846
#define	M_E		2.7182818284590452354
#define	M_LOG10E	0.43429448190325182765
#define	M_LN10		2.30258509299404568402
#define	M_PI_2		1.57079632679489661923
#define	M_PI_4		0.78539816339744830962
#define	M_1_PI		0.31830988618379067154
#define	M_2_PI		0.63661977236758134308
#define	M_2_SQRTPI	1.12837916709551257390
#define	M_SQRT2		1.41421356237309504880
#define	M_SQRT1_2	0.70710678118654752440

// 80 bit
#define	M_PI_L		0x1.921fb54442d1846ap+1L	// 3.14159 fldpi
#define	M_LOG2T_L	0x1.a934f0979a3715fcp+1L	// 3.32193 fldl2t
#define	M_LOG2E_L	0x1.71547652b82fe178p+0L	// 1.4427 fldl2e
#define	M_LOG2_L	0x1.34413509f79fef32p-2L	// 0.30103 fldlg2
#define	M_LN2_L		0x1.62e42fefa39ef358p-1L	// 0.693147 fldln2

#ifndef _EXCEPTION_DEFINED

struct _exception
{	int type;
	char *name;
	double arg1;
	double arg2;
	double retval;
};

#if !__STDC__
#define exception _exception
#endif

#define _exceptionl _exception

#define _EXCEPTION_DEFINED
#endif 


#define _DOMAIN		1
#define _SING		2
#define	_OVERFLOW	3
#define _UNDERFLOW	4
#define _TLOSS		5
#define _PLOSS		6

#define EDOM            33
#define ERANGE          34

#ifndef __STDC__
#define DOMAIN		_DOMAIN
#define SING		_SING
#define	OVERFLOW	_OVERFLOW
#define UNDERFLOW	_UNDERFLOW
#define TLOSS		_TLOSS
#define PLOSS		_PLOSS
#define DIVIDE_BY_ZERO  7
#endif

int	__cdecl matherr(struct _exception *);
double	__cdecl atof(const char *);
#define _atold atof
#define _matherr matherr
double	__cdecl poly(double,int,double []);
#define polyl poly
double _poly87(double, int, double []);

#if 1
#define poly _poly87
#endif


#endif

#if __cplusplus
#endif 

#endif

/* Copyright (C) 1986-2001 by Digital Mars. $Revision: 1.1.1.1 $ */
#if 0x857 || __RCC__
#pragma once
#endif


#ifndef __ERRNO_H
#define __ERRNO_H 1

#if __cplusplus
#endif 

/* Define _CRTAPI1 (for compatibility with the NT SDK) */
#ifndef _CRTAPI1
#endif 

/* Define _CRTAPI2 (for compatibility with the NT SDK) */
#ifndef _CRTAPI2
#endif 

/* Define CRTIMP */
#ifndef _CRTIMP
#endif 

#if __OS2__ && 4 == 4
#else
#define __CLIB	__cdecl
#endif

#if defined(_MT) || defined(_DLL) || __cplusplus
#else
extern int __cdecl errno;
#endif

#if M_UNIX || M_XENIX
#else

#define EZERO        0
#define EPERM        1
#define ENOENT       2
#define ESRCH        3
#define EINTR        4
#define EIO          5
#define ENXIO        6
#define E2BIG        7
#define ENOEXEC      8
#define EBADF        9
#define ECHILD       10
#define EAGAIN       11
#define ENOMEM       12
#define EACCES       13
#define EFAULT       14
#define ENOTBLK      15
#define EBUSY        16
#define EEXIST       17
#define EXDEV        18
#define ENODEV       19
#define ENOTDIR      20
#define EISDIR       21
#define EINVAL       22
#define ENFILE       23
#define EMFILE       24
#define ENOTTY       25
#define ETXTBSY      26
#define EFBIG        27
#define ENOSPC       28
#define ESPIPE       29
#define EROFS        30
#define EMLINK       31
#define EPIPE        32
#define EDOM         33
#define ERANGE       34
#define EUCLEAN      35
#define EDEADLOCK    36
#define EDEADLK      36
#define ENAMETOOLONG 38
#define ENOLCK       39
#define ENOSYS       40
#define ENOTEMPTY    41
#define EILSEQ       42

#endif /* M_UNIX || M_XENIX */

#if __cplusplus
#endif 

#endif


/* Copyright (C) 1986-2002 by Digital Mars.
 * All Rights Reserved
 * www.digitalmars.com
 */

#if 0x857 || __RCC__
#pragma once
#endif

#ifndef __CTYPE_H
#define __CTYPE_H 1

#if __cplusplus
#endif 

#ifndef __STDC__

#if !defined(_WCHAR_T_DEFINED)
#endif 

#if !defined(_WCTYPE_T_DEFINED)
typedef wchar_t wint_t;
typedef wchar_t wctype_t;
#define _WCTYPE_T_DEFINED 1
#endif

#ifndef WEOF
#endif 

#endif

#if __OS2__ && 4 == 4
#else
#define __CLIB	__cdecl
#endif

/* Define _CRTAPI1 (for compatibility with the NT SDK) */
#ifndef _CRTAPI1
#endif 


/* Define _CRTAPI2 (for compatibility with the NT SDK) */
#ifndef _CRTAPI2
#endif 

/* Define CRTIMP  */
#ifndef _CRTIMP
#endif 

#define _SPC	8
#define _CTL	0x20
#define _BLK	0x40
#define _HEX	0x80
#define _UC	1
#define _LC	2
#define _PNC	0x10
#define _DIG	4
#ifdef __NT__
#define _ALP	(0x0100|_UC|_LC)
#define _LEADBYTE 0x8000
#else
#endif 

#define _UPPER _UC
#define _LOWER _LC
#define _DIGIT _DIG
#define _SPACE _SPC
#define _PUNCT _PNC
#define _CONTROL _CTL
#define _BLANK _BLK
#define _ALPHA _ALP

#ifdef __NT__
#ifdef M_ELF
#endif 

extern unsigned short * __cdecl	_pctype;
#ifndef __STDC__
extern wctype_t * __cdecl	_pwctype;
#endif
extern unsigned short __cdecl	_ctype[];
#else
#endif 

#ifdef __NT__
int	__cdecl _isctype(int, int);
#endif

int	__cdecl isalnum(int);
int	__cdecl isalpha(int);
int	__cdecl isblank(int);
int	__cdecl iscntrl(int);
int	__cdecl isdigit(int);
int	__cdecl isgraph(int);
int	__cdecl islower(int);
int	__cdecl isprint(int);
int	__cdecl ispunct(int);
int	__cdecl isspace(int);
int	__cdecl isupper(int);
int	__cdecl isxdigit(int);
int	__cdecl toupper(int);
int	__cdecl tolower(int);

#ifndef __STDC__
int	__cdecl isascii(int);
int	__cdecl __isascii(int);
int	__cdecl iscsym(int);
int	__cdecl __iscsym(int);
int	__cdecl iscsymf(int);
int	__cdecl __iscsymf(int);
int	__cdecl toascii(int);
int	__cdecl __toascii(int);
int 	__cdecl _toupper(int);
int	__cdecl _tolower(int);
#endif

#ifdef __NT__
#ifndef __STDC__
#ifndef iswalpha
int __cdecl iswalpha(wint_t);
int __cdecl iswblank(wint_t);
int __cdecl iswupper(wint_t);
int __cdecl iswlower(wint_t);
int __cdecl iswdigit(wint_t);
int __cdecl iswxdigit(wint_t);
int __cdecl iswspace(wint_t);
int __cdecl iswpunct(wint_t);
int __cdecl iswalnum(wint_t);
int __cdecl iswprint(wint_t);
int __cdecl iswgraph(wint_t);
int __cdecl iswcntrl(wint_t);
int __cdecl iswascii(wint_t);
int __cdecl isleadbyte(int);
wchar_t __cdecl towupper(wchar_t);
 wchar_t __cdecl towlower(wchar_t);
int __cdecl iswctype(wint_t, wctype_t);
#define is_wctype	iswctype
#endif
#endif
#endif

#ifdef __NT__
extern int __cdecl __locale_mbsize;
#define MB_CUR_MAX	__locale_mbsize
#define isalnum(c)	(MB_CUR_MAX>1?_isctype(c,_ALP|_DIG):_pctype[c]&(_ALP|_DIG))
#define isalpha(c)	(MB_CUR_MAX>1?_isctype(c,_ALP):_pctype[c]&_ALP)
#define iscntrl(c)	(MB_CUR_MAX>1?_isctype(c,_CTL):_pctype[c]&_CTL)
#define isdigit(c)	(MB_CUR_MAX>1?_isctype(c,_DIG):_pctype[c]&_DIG)
#define isgraph(c)	(MB_CUR_MAX>1?_isctype(c,_ALP|_DIG|_PNC):_pctype[c]&(_ALP|_DIG|_PNC))
#define islower(c)	(MB_CUR_MAX>1?_isctype(c,_LC):_pctype[c]&_LC)
#define isprint(c)	(MB_CUR_MAX>1?_isctype(c,_ALP|_DIG|_PNC|_BLK):_pctype[c]&(_ALP|_DIG|_PNC|_BLK))
#define ispunct(c)	(MB_CUR_MAX>1?_isctype(c,_PNC):_pctype[c]&_PNC)
#define isspace(c)	(MB_CUR_MAX>1?_isctype(c,_SPC):_pctype[c]&_SPC)
#define isupper(c)	(MB_CUR_MAX>1?_isctype(c,_UC):_pctype[c]&_UC)
#define isxdigit(c)	(MB_CUR_MAX>1?_isctype(c,_HEX):_pctype[c]&_HEX)
#define isleadbyte(c)	(_pctype[(unsigned char)(c)]&_LEADBYTE)
#else
#endif 

#ifndef __STDC__
#if !defined(_WIN32)
#endif 
#define isascii(c)	((unsigned)(c)<0200)
#define __isascii(c)	((unsigned)(c)<0200)
#define iscsym(c)	((_ctype[(c)+1]&(_UC|_LC|_DIG))||((c)=='_'))
#define __iscsym(c)	((_ctype[(c)+1]&(_UC|_LC|_DIG))||((c)=='_'))
#define iscsymf(c)	((_ctype[(c)+1]&(_UC|_LC))||((c)=='_'))
#define __iscsymf(c)	((_ctype[(c)+1]&(_UC|_LC))||((c)=='_'))
#define toascii(c)	((c)&0x7F)
#define __toascii(c)	((c)&0x7F)
#define _tolower(c)	((c)+('a'-'A'))
#define _toupper(c)	((c)-('a'-'A'))
#endif

#ifdef __NT__
#ifndef __STDC__
#define iswalpha(c)	(iswctype(c, _ALPHA))
#define iswupper(c)	(iswctype(c, _UPPER))
#define iswlower(c)	(iswctype(c, _LOWER))
#define iswdigit(c)	(iswctype(c, _DIGIT))
#define iswxdigit(c)	(iswctype(c, _HEX))
#define iswspace(c)	(iswctype(c, _SPACE))
#define iswpunct(c)	(iswctype(c, _PUNCT))
#define iswalnum(c)	(iswctype(c, _ALPHA|_DIGIT))
#define iswprint(c)	(iswctype(c, _BLANK|_PUNCT|_ALPHA|_DIGIT))
#define iswgraph(c)	(iswctype(c, _PUNCT|_ALPHA|_DIGIT))
#define iswcntrl(c)	(iswctype(c, _CONTROL))
#define iswascii(c)	((unsigned)(c) < 0x80)
#endif
#endif

#if __cplusplus
#endif 

#endif


/*
** State Type
*/

typedef struct {
  long pos;
  long row;
  long col;
  int term;
} mpc_state_t;

/*
** Error Type
*/

typedef struct {
  mpc_state_t state;
  int expected_num;
  char *filename;
  char *failure;
  char **expected;
  char received;
} mpc_err_t;

void mpc_err_delete(mpc_err_t *e);
char *mpc_err_string(mpc_err_t *e);
void mpc_err_print(mpc_err_t *e);
void mpc_err_print_to(mpc_err_t *e, FILE *f);

/*
** Parsing
*/

typedef void mpc_val_t;

typedef union {
  mpc_err_t *error;
  mpc_val_t *output;
} mpc_result_t;

struct mpc_parser_t;
typedef struct mpc_parser_t mpc_parser_t;

int mpc_parse(const char *filename, const char *string, mpc_parser_t *p, mpc_result_t *r);
int mpc_nparse(const char *filename, const char *string, size_t length, mpc_parser_t *p, mpc_result_t *r);
int mpc_parse_file(const char *filename, FILE *file, mpc_parser_t *p, mpc_result_t *r);
int mpc_parse_pipe(const char *filename, FILE *pipe, mpc_parser_t *p, mpc_result_t *r);
int mpc_parse_contents(const char *filename, mpc_parser_t *p, mpc_result_t *r);

/*
** Function Types
*/

typedef void(*mpc_dtor_t)(mpc_val_t*);
typedef mpc_val_t*(*mpc_ctor_t)(void);

typedef mpc_val_t*(*mpc_apply_t)(mpc_val_t*);
typedef mpc_val_t*(*mpc_apply_to_t)(mpc_val_t*,void*);
typedef mpc_val_t*(*mpc_fold_t)(int,mpc_val_t**);

typedef int(*mpc_check_t)(mpc_val_t**);
typedef int(*mpc_check_with_t)(mpc_val_t**,void*);

/*
** Building a Parser
*/

mpc_parser_t *mpc_new(const char *name);
mpc_parser_t *mpc_copy(mpc_parser_t *a);
mpc_parser_t *mpc_define(mpc_parser_t *p, mpc_parser_t *a);
mpc_parser_t *mpc_undefine(mpc_parser_t *p);

void mpc_delete(mpc_parser_t *p);
void mpc_cleanup(int n, ...);

/*
** Basic Parsers
*/

mpc_parser_t *mpc_any(void);
mpc_parser_t *mpc_char(char c);
mpc_parser_t *mpc_range(char s, char e);
mpc_parser_t *mpc_oneof(const char *s);
mpc_parser_t *mpc_noneof(const char *s);
mpc_parser_t *mpc_satisfy(int(*f)(char));
mpc_parser_t *mpc_string(const char *s);

/*
** Other Parsers
*/

mpc_parser_t *mpc_pass(void);
mpc_parser_t *mpc_fail(const char *m);
mpc_parser_t *mpc_failf(const char *fmt, ...);
mpc_parser_t *mpc_lift(mpc_ctor_t f);
mpc_parser_t *mpc_lift_val(mpc_val_t *x);
mpc_parser_t *mpc_anchor(int(*f)(char,char));
mpc_parser_t *mpc_state(void);

/*
** Combinator Parsers
*/

mpc_parser_t *mpc_expect(mpc_parser_t *a, const char *e);
mpc_parser_t *mpc_expectf(mpc_parser_t *a, const char *fmt, ...);
mpc_parser_t *mpc_apply(mpc_parser_t *a, mpc_apply_t f);
mpc_parser_t *mpc_apply_to(mpc_parser_t *a, mpc_apply_to_t f, void *x);
mpc_parser_t *mpc_check(mpc_parser_t *a, mpc_dtor_t da, mpc_check_t f, const char *e);
mpc_parser_t *mpc_check_with(mpc_parser_t *a, mpc_dtor_t da, mpc_check_with_t f, void *x, const char *e);
mpc_parser_t *mpc_checkf(mpc_parser_t *a, mpc_dtor_t da, mpc_check_t f, const char *fmt, ...);
mpc_parser_t *mpc_check_withf(mpc_parser_t *a, mpc_dtor_t da, mpc_check_with_t f, void *x, const char *fmt, ...);

mpc_parser_t *mpc_not(mpc_parser_t *a, mpc_dtor_t da);
mpc_parser_t *mpc_not_lift(mpc_parser_t *a, mpc_dtor_t da, mpc_ctor_t lf);
mpc_parser_t *mpc_maybe(mpc_parser_t *a);
mpc_parser_t *mpc_maybe_lift(mpc_parser_t *a, mpc_ctor_t lf);

mpc_parser_t *mpc_many(mpc_fold_t f, mpc_parser_t *a);
mpc_parser_t *mpc_many1(mpc_fold_t f, mpc_parser_t *a);
mpc_parser_t *mpc_count(int n, mpc_fold_t f, mpc_parser_t *a, mpc_dtor_t da);

mpc_parser_t *mpc_or(int n, ...);
mpc_parser_t *mpc_and(int n, mpc_fold_t f, ...);

mpc_parser_t *mpc_predictive(mpc_parser_t *a);

/*
** Common Parsers
*/

mpc_parser_t *mpc_eoi(void);
mpc_parser_t *mpc_soi(void);

mpc_parser_t *mpc_boundary(void);
mpc_parser_t *mpc_boundary_newline(void);

mpc_parser_t *mpc_whitespace(void);
mpc_parser_t *mpc_whitespaces(void);
mpc_parser_t *mpc_blank(void);

mpc_parser_t *mpc_newline(void);
mpc_parser_t *mpc_tab(void);
mpc_parser_t *mpc_escape(void);

mpc_parser_t *mpc_digit(void);
mpc_parser_t *mpc_hexdigit(void);
mpc_parser_t *mpc_octdigit(void);
mpc_parser_t *mpc_digits(void);
mpc_parser_t *mpc_hexdigits(void);
mpc_parser_t *mpc_octdigits(void);

mpc_parser_t *mpc_lower(void);
mpc_parser_t *mpc_upper(void);
mpc_parser_t *mpc_alpha(void);
mpc_parser_t *mpc_underscore(void);
mpc_parser_t *mpc_alphanum(void);

mpc_parser_t *mpc_int(void);
mpc_parser_t *mpc_hex(void);
mpc_parser_t *mpc_oct(void);
mpc_parser_t *mpc_number(void);

mpc_parser_t *mpc_real(void);
mpc_parser_t *mpc_float(void);

mpc_parser_t *mpc_char_lit(void);
mpc_parser_t *mpc_string_lit(void);
mpc_parser_t *mpc_regex_lit(void);

mpc_parser_t *mpc_ident(void);

/*
** Useful Parsers
*/

mpc_parser_t *mpc_startwith(mpc_parser_t *a);
mpc_parser_t *mpc_endwith(mpc_parser_t *a, mpc_dtor_t da);
mpc_parser_t *mpc_whole(mpc_parser_t *a, mpc_dtor_t da);

mpc_parser_t *mpc_stripl(mpc_parser_t *a);
mpc_parser_t *mpc_stripr(mpc_parser_t *a);
mpc_parser_t *mpc_strip(mpc_parser_t *a);
mpc_parser_t *mpc_tok(mpc_parser_t *a);
mpc_parser_t *mpc_sym(const char *s);
mpc_parser_t *mpc_total(mpc_parser_t *a, mpc_dtor_t da);

mpc_parser_t *mpc_between(mpc_parser_t *a, mpc_dtor_t ad, const char *o, const char *c);
mpc_parser_t *mpc_parens(mpc_parser_t *a, mpc_dtor_t ad);
mpc_parser_t *mpc_braces(mpc_parser_t *a, mpc_dtor_t ad);
mpc_parser_t *mpc_brackets(mpc_parser_t *a, mpc_dtor_t ad);
mpc_parser_t *mpc_squares(mpc_parser_t *a, mpc_dtor_t ad);

mpc_parser_t *mpc_tok_between(mpc_parser_t *a, mpc_dtor_t ad, const char *o, const char *c);
mpc_parser_t *mpc_tok_parens(mpc_parser_t *a, mpc_dtor_t ad);
mpc_parser_t *mpc_tok_braces(mpc_parser_t *a, mpc_dtor_t ad);
mpc_parser_t *mpc_tok_brackets(mpc_parser_t *a, mpc_dtor_t ad);
mpc_parser_t *mpc_tok_squares(mpc_parser_t *a, mpc_dtor_t ad);

/*
** Common Function Parameters
*/

void mpcf_dtor_null(mpc_val_t *x);

mpc_val_t *mpcf_ctor_null(void);
mpc_val_t *mpcf_ctor_str(void);

mpc_val_t *mpcf_free(mpc_val_t *x);
mpc_val_t *mpcf_int(mpc_val_t *x);
mpc_val_t *mpcf_hex(mpc_val_t *x);
mpc_val_t *mpcf_oct(mpc_val_t *x);
mpc_val_t *mpcf_float(mpc_val_t *x);
mpc_val_t *mpcf_strtriml(mpc_val_t *x);
mpc_val_t *mpcf_strtrimr(mpc_val_t *x);
mpc_val_t *mpcf_strtrim(mpc_val_t *x);

mpc_val_t *mpcf_escape(mpc_val_t *x);
mpc_val_t *mpcf_escape_regex(mpc_val_t *x);
mpc_val_t *mpcf_escape_string_raw(mpc_val_t *x);
mpc_val_t *mpcf_escape_char_raw(mpc_val_t *x);

mpc_val_t *mpcf_unescape(mpc_val_t *x);
mpc_val_t *mpcf_unescape_regex(mpc_val_t *x);
mpc_val_t *mpcf_unescape_string_raw(mpc_val_t *x);
mpc_val_t *mpcf_unescape_char_raw(mpc_val_t *x);

mpc_val_t *mpcf_null(int n, mpc_val_t** xs);
mpc_val_t *mpcf_fst(int n, mpc_val_t** xs);
mpc_val_t *mpcf_snd(int n, mpc_val_t** xs);
mpc_val_t *mpcf_trd(int n, mpc_val_t** xs);

mpc_val_t *mpcf_fst_free(int n, mpc_val_t** xs);
mpc_val_t *mpcf_snd_free(int n, mpc_val_t** xs);
mpc_val_t *mpcf_trd_free(int n, mpc_val_t** xs);
mpc_val_t *mpcf_all_free(int n, mpc_val_t** xs);

mpc_val_t *mpcf_freefold(int n, mpc_val_t** xs);
mpc_val_t *mpcf_strfold(int n, mpc_val_t** xs);
mpc_val_t *mpcf_maths(int n, mpc_val_t** xs);

/*
** Regular Expression Parsers
*/

enum {
  MPC_RE_DEFAULT   = 0,
  MPC_RE_M         = 1,
  MPC_RE_S         = 2,
  MPC_RE_MULTILINE = 1,
  MPC_RE_DOTALL    = 2
};

mpc_parser_t *mpc_re(const char *re);
mpc_parser_t *mpc_re_mode(const char *re, int mode);

/*
** AST
*/

typedef struct mpc_ast_t {
  char *tag;
  char *contents;
  mpc_state_t state;
  int children_num;
  struct mpc_ast_t** children;
} mpc_ast_t;

mpc_ast_t *mpc_ast_new(const char *tag, const char *contents);
mpc_ast_t *mpc_ast_build(int n, const char *tag, ...);
mpc_ast_t *mpc_ast_add_root(mpc_ast_t *a);
mpc_ast_t *mpc_ast_add_child(mpc_ast_t *r, mpc_ast_t *a);
mpc_ast_t *mpc_ast_add_tag(mpc_ast_t *a, const char *t);
mpc_ast_t *mpc_ast_add_root_tag(mpc_ast_t *a, const char *t);
mpc_ast_t *mpc_ast_tag(mpc_ast_t *a, const char *t);
mpc_ast_t *mpc_ast_state(mpc_ast_t *a, mpc_state_t s);

void mpc_ast_delete(mpc_ast_t *a);
void mpc_ast_print(mpc_ast_t *a);
void mpc_ast_print_to(mpc_ast_t *a, FILE *fp);

int mpc_ast_get_index(mpc_ast_t *ast, const char *tag);
int mpc_ast_get_index_lb(mpc_ast_t *ast, const char *tag, int lb);
mpc_ast_t *mpc_ast_get_child(mpc_ast_t *ast, const char *tag);
mpc_ast_t *mpc_ast_get_child_lb(mpc_ast_t *ast, const char *tag, int lb);

typedef enum {
  mpc_ast_trav_order_pre,
  mpc_ast_trav_order_post
} mpc_ast_trav_order_t;

typedef struct mpc_ast_trav_t {
  mpc_ast_t             *curr_node;
  struct mpc_ast_trav_t *parent;
  int                    curr_child;
  mpc_ast_trav_order_t   order;
} mpc_ast_trav_t;

mpc_ast_trav_t *mpc_ast_traverse_start(mpc_ast_t *ast,
                                       mpc_ast_trav_order_t order);

mpc_ast_t *mpc_ast_traverse_next(mpc_ast_trav_t **trav);

void mpc_ast_traverse_free(mpc_ast_trav_t **trav);

/*
** Warning: This function currently doesn't test for equality of the `state` member!
*/
int mpc_ast_eq(mpc_ast_t *a, mpc_ast_t *b);

mpc_val_t *mpcf_fold_ast(int n, mpc_val_t **as);
mpc_val_t *mpcf_str_ast(mpc_val_t *c);
mpc_val_t *mpcf_state_ast(int n, mpc_val_t **xs);

mpc_parser_t *mpca_tag(mpc_parser_t *a, const char *t);
mpc_parser_t *mpca_add_tag(mpc_parser_t *a, const char *t);
mpc_parser_t *mpca_root(mpc_parser_t *a);
mpc_parser_t *mpca_state(mpc_parser_t *a);
mpc_parser_t *mpca_total(mpc_parser_t *a);

mpc_parser_t *mpca_not(mpc_parser_t *a);
mpc_parser_t *mpca_maybe(mpc_parser_t *a);

mpc_parser_t *mpca_many(mpc_parser_t *a);
mpc_parser_t *mpca_many1(mpc_parser_t *a);
mpc_parser_t *mpca_count(int n, mpc_parser_t *a);

mpc_parser_t *mpca_or(int n, ...);
mpc_parser_t *mpca_and(int n, ...);

enum {
  MPCA_LANG_DEFAULT              = 0,
  MPCA_LANG_PREDICTIVE           = 1,
  MPCA_LANG_WHITESPACE_SENSITIVE = 2
};

mpc_parser_t *mpca_grammar(int flags, const char *grammar, ...);

mpc_err_t *mpca_lang(int flags, const char *language, ...);
mpc_err_t *mpca_lang_file(int flags, FILE *f, ...);
mpc_err_t *mpca_lang_pipe(int flags, FILE *f, ...);
mpc_err_t *mpca_lang_contents(int flags, const char *filename, ...);

/*
** Misc
*/


void mpc_print(mpc_parser_t *p);
void mpc_optimise(mpc_parser_t *p);
void mpc_stats(mpc_parser_t *p);

int mpc_test_pass(mpc_parser_t *p, const char *s, const void *d,
  int(*tester)(const void*, const void*),
  mpc_dtor_t destructor,
  void(*printer)(const void*));

int mpc_test_fail(mpc_parser_t *p, const char *s, const void *d,
  int(*tester)(const void*, const void*),
  mpc_dtor_t destructor,
  void(*printer)(const void*));

#ifdef __cplusplus
#endif 

#endif


/*
** State Type
*/

static mpc_state_t mpc_state_invalid(void) {
  mpc_state_t s;
  s.pos = -1;
  s.row = -1;
  s.col = -1;
  s.term = 0;
  return s;
}

static mpc_state_t mpc_state_new(void) {
  mpc_state_t s;
  s.pos = 0;
  s.row = 0;
  s.col = 0;
  s.term = 0;
  return s;
}

/*
** Input Type
*/

/*
** In mpc the input type has three modes of
** operation: String, File and Pipe.
**
** String is easy. The whole contents are
** loaded into a buffer and scanned through.
** The cursor can jump around at will making
** backtracking easy.
**
** The second is a File which is also somewhat
** easy. The contents are never loaded into
** memory but backtracking can still be achieved
** by seeking in the file at different positions.
**
** The final mode is Pipe. This is the difficult
** one. As we assume pipes cannot be seeked - and
** only support a single character lookahead at
** any point, when the input is marked for a
** potential backtracking we start buffering any
** input.
**
** This means that if we are requested to seek
** back we can simply start reading from the
** buffer instead of the input.
**
** Of course using `mpc_predictive` will disable
** backtracking and make LL(1) grammars easy
** to parse for all input methods.
**
*/

enum {
  MPC_INPUT_STRING = 0,
  MPC_INPUT_FILE   = 1,
  MPC_INPUT_PIPE   = 2
};

enum {
  MPC_INPUT_MARKS_MIN = 32
};

enum {
  MPC_INPUT_MEM_NUM = 512
};

typedef struct {
  char mem[64];
} mpc_mem_t;

typedef struct {

  int type;
  char *filename;
  mpc_state_t state;

  char *string;
  char *buffer;
  FILE *file;

  int suppress;
  int backtrack;
  int marks_slots;
  int marks_num;
  mpc_state_t *marks;

  char *lasts;
  char last;

  size_t mem_index;
  char mem_full[MPC_INPUT_MEM_NUM];
  mpc_mem_t mem[MPC_INPUT_MEM_NUM];

} mpc_input_t;

static mpc_input_t *mpc_input_new_string(const char *filename, const char *string) {

  mpc_input_t *i = malloc(sizeof(mpc_input_t));

  i->filename = malloc(strlen(filename) + 1);
  strcpy(i->filename, filename);
  i->type = MPC_INPUT_STRING;

  i->state = mpc_state_new();

  i->string = malloc(strlen(string) + 1);
  strcpy(i->string, string);
  i->buffer = ((void *)0);
  i->file = ((void *)0);

  i->suppress = 0;
  i->backtrack = 1;
  i->marks_num = 0;
  i->marks_slots = MPC_INPUT_MARKS_MIN;
  i->marks = malloc(sizeof(mpc_state_t) * i->marks_slots);
  i->lasts = malloc(sizeof(char) * i->marks_slots);
  i->last = '\0';

  i->mem_index = 0;
  memset(i->mem_full, 0, sizeof(char) * MPC_INPUT_MEM_NUM);

  return i;
}

static mpc_input_t *mpc_input_new_nstring(const char *filename, const char *string, size_t length) {

  mpc_input_t *i = malloc(sizeof(mpc_input_t));

  i->filename = malloc(strlen(filename) + 1);
  strcpy(i->filename, filename);
  i->type = MPC_INPUT_STRING;

  i->state = mpc_state_new();

  i->string = malloc(length + 1);
  strncpy(i->string, string, length);
  i->string[length] = '\0';
  i->buffer = ((void *)0);
  i->file = ((void *)0);

  i->suppress = 0;
  i->backtrack = 1;
  i->marks_num = 0;
  i->marks_slots = MPC_INPUT_MARKS_MIN;
  i->marks = malloc(sizeof(mpc_state_t) * i->marks_slots);
  i->lasts = malloc(sizeof(char) * i->marks_slots);
  i->last = '\0';

  i->mem_index = 0;
  memset(i->mem_full, 0, sizeof(char) * MPC_INPUT_MEM_NUM);

  return i;

}

static mpc_input_t *mpc_input_new_pipe(const char *filename, FILE *pipe) {

  mpc_input_t *i = malloc(sizeof(mpc_input_t));

  i->filename = malloc(strlen(filename) + 1);
  strcpy(i->filename, filename);

  i->type = MPC_INPUT_PIPE;
  i->state = mpc_state_new();

  i->string = ((void *)0);
  i->buffer = ((void *)0);
  i->file = pipe;

  i->suppress = 0;
  i->backtrack = 1;
  i->marks_num = 0;
  i->marks_slots = MPC_INPUT_MARKS_MIN;
  i->marks = malloc(sizeof(mpc_state_t) * i->marks_slots);
  i->lasts = malloc(sizeof(char) * i->marks_slots);
  i->last = '\0';

  i->mem_index = 0;
  memset(i->mem_full, 0, sizeof(char) * MPC_INPUT_MEM_NUM);

  return i;

}

static mpc_input_t *mpc_input_new_file(const char *filename, FILE *file) {

  mpc_input_t *i = malloc(sizeof(mpc_input_t));

  i->filename = malloc(strlen(filename) + 1);
  strcpy(i->filename, filename);
  i->type = MPC_INPUT_FILE;
  i->state = mpc_state_new();

  i->string = ((void *)0);
  i->buffer = ((void *)0);
  i->file = file;

  i->suppress = 0;
  i->backtrack = 1;
  i->marks_num = 0;
  i->marks_slots = MPC_INPUT_MARKS_MIN;
  i->marks = malloc(sizeof(mpc_state_t) * i->marks_slots);
  i->lasts = malloc(sizeof(char) * i->marks_slots);
  i->last = '\0';

  i->mem_index = 0;
  memset(i->mem_full, 0, sizeof(char) * MPC_INPUT_MEM_NUM);

  return i;
}

static void mpc_input_delete(mpc_input_t *i) {

  free(i->filename);

  if (i->type == MPC_INPUT_STRING) { free(i->string); }
  if (i->type == MPC_INPUT_PIPE) { free(i->buffer); }

  free(i->marks);
  free(i->lasts);
  free(i);
}

static int mpc_mem_ptr(mpc_input_t *i, void *p) {
  return
    (char*)p >= (char*)(i->mem) &&
    (char*)p <  (char*)(i->mem) + (MPC_INPUT_MEM_NUM * sizeof(mpc_mem_t));
}

static void *mpc_malloc(mpc_input_t *i, size_t n) {
  size_t j;
  char *p;

  if (n > sizeof(mpc_mem_t)) { return malloc(n); }

  j = i->mem_index;
  do {
    if (!i->mem_full[i->mem_index]) {
      p = (void*)(i->mem + i->mem_index);
      i->mem_full[i->mem_index] = 1;
      i->mem_index = (i->mem_index+1) % MPC_INPUT_MEM_NUM;
      return p;
    }
    i->mem_index = (i->mem_index+1) % MPC_INPUT_MEM_NUM;
  } while (j != i->mem_index);

  return malloc(n);
}

static void *mpc_calloc(mpc_input_t *i, size_t n, size_t m) {
  char *x = mpc_malloc(i, n * m);
  memset(x, 0, n * m);
  return x;
}

static void mpc_free(mpc_input_t *i, void *p) {
  size_t j;
  if (!mpc_mem_ptr(i, p)) { free(p); return; }
  j = ((size_t)(((char*)p) - ((char*)i->mem))) / sizeof(mpc_mem_t);
  i->mem_full[j] = 0;
}

static void *mpc_realloc(mpc_input_t *i, void *p, size_t n) {

  char *q = ((void *)0);

  if (!mpc_mem_ptr(i, p)) { return realloc(p, n); }

  if (n > sizeof(mpc_mem_t)) {
    q = malloc(n);
    memcpy(q, p, sizeof(mpc_mem_t));
    mpc_free(i, p);
    return q;
  }

  return p;
}

static void *mpc_export(mpc_input_t *i, void *p) {
  char *q = ((void *)0);
  if (!mpc_mem_ptr(i, p)) { return p; }
  q = malloc(sizeof(mpc_mem_t));
  memcpy(q, p, sizeof(mpc_mem_t));
  mpc_free(i, p);
  return q;
}

static void mpc_input_backtrack_disable(mpc_input_t *i) { i->backtrack--; }
static void mpc_input_backtrack_enable(mpc_input_t *i) { i->backtrack++; }

static void mpc_input_suppress_disable(mpc_input_t *i) { i->suppress--; }
static void mpc_input_suppress_enable(mpc_input_t *i) { i->suppress++; }

static void mpc_input_mark(mpc_input_t *i) {

  if (i->backtrack < 1) { return; }

  i->marks_num++;

  if (i->marks_num > i->marks_slots) {
    i->marks_slots = i->marks_num + i->marks_num / 2;
    i->marks = realloc(i->marks, sizeof(mpc_state_t) * i->marks_slots);
    i->lasts = realloc(i->lasts, sizeof(char) * i->marks_slots);
  }

  i->marks[i->marks_num-1] = i->state;
  i->lasts[i->marks_num-1] = i->last;

  if (i->type == MPC_INPUT_PIPE && i->marks_num == 1) {
    i->buffer = calloc(1, 1);
  }

}

static void mpc_input_unmark(mpc_input_t *i) {
  int j;

  if (i->backtrack < 1) { return; }

  i->marks_num--;

  if (i->marks_slots > i->marks_num + i->marks_num / 2
  &&  i->marks_slots > MPC_INPUT_MARKS_MIN) {
    i->marks_slots =
      i->marks_num > MPC_INPUT_MARKS_MIN ?
      i->marks_num : MPC_INPUT_MARKS_MIN;
    i->marks = realloc(i->marks, sizeof(mpc_state_t) * i->marks_slots);
    i->lasts = realloc(i->lasts, sizeof(char) * i->marks_slots);
  }

  if (i->type == MPC_INPUT_PIPE && i->marks_num == 0) {
    for (j = strlen(i->buffer) - 1; j >= 0; j--)
      ungetc(i->buffer[j], i->file);

    free(i->buffer);
    i->buffer = ((void *)0);
  }

}

static void mpc_input_rewind(mpc_input_t *i) {

  if (i->backtrack < 1) { return; }

  i->state = i->marks[i->marks_num-1];
  i->last  = i->lasts[i->marks_num-1];

  if (i->type == MPC_INPUT_FILE) {
    fseek(i->file, i->state.pos, 0);
  }

  mpc_input_unmark(i);
}

static int mpc_input_buffer_in_range(mpc_input_t *i) {
  return i->state.pos < (long)(strlen(i->buffer) + i->marks[0].pos);
}

static char mpc_input_buffer_get(mpc_input_t *i) {
  return i->buffer[i->state.pos - i->marks[0].pos];
}

static char mpc_input_getc(mpc_input_t *i) {

  char c = '\0';

  switch (i->type) {

    case MPC_INPUT_STRING: return i->string[i->state.pos];
    case MPC_INPUT_FILE: c = fgetc(i->file); return c;
    case MPC_INPUT_PIPE:

      if (!i->buffer) { c = fgetc(i->file); return c; }

      if (i->buffer && mpc_input_buffer_in_range(i)) {
        c = mpc_input_buffer_get(i);
        return c;
      } else {
        c = fgetc(i->file);
        return c;
      }

    default: return c;
  }
}

static char mpc_input_peekc(mpc_input_t *i) {

  char c = '\0';

  switch (i->type) {
    case MPC_INPUT_STRING: return i->string[i->state.pos];
    case MPC_INPUT_FILE:

      c = fgetc(i->file);
      if (((i->file)->_flag&0x10)) { return '\0'; }

      fseek(i->file, -1, 1);
      return c;

    case MPC_INPUT_PIPE:

      if (!i->buffer) {
        c = fgetc(i->file);
        if (((i->file)->_flag&0x10)) { return '\0'; }
        ungetc(c, i->file);
        return c;
      }

      if (i->buffer && mpc_input_buffer_in_range(i)) {
        return mpc_input_buffer_get(i);
      } else {
        c = fgetc(i->file);
        if (((i->file)->_flag&0x10)) { return '\0'; }
        ungetc(c, i->file);
        return c;
      }

    default: return c;
  }

}

static int mpc_input_terminated(mpc_input_t *i) {
  return mpc_input_peekc(i) == '\0';
}

static int mpc_input_failure(mpc_input_t *i, char c) {

  switch (i->type) {
    case MPC_INPUT_STRING: { break; }
    case MPC_INPUT_FILE: fseek(i->file, -1, 1); { break; }
    case MPC_INPUT_PIPE: {

      if (!i->buffer) { ungetc(c, i->file); break; }

      if (i->buffer && mpc_input_buffer_in_range(i)) {
        break;
      } else {
        ungetc(c, i->file);
      }
    }
    default: { break; }
  }
  return 0;
}

static int mpc_input_success(mpc_input_t *i, char c, char **o) {

  if (i->type == MPC_INPUT_PIPE
  &&  i->buffer && !mpc_input_buffer_in_range(i)) {
    i->buffer = realloc(i->buffer, strlen(i->buffer) + 2);
    i->buffer[strlen(i->buffer) + 1] = '\0';
    i->buffer[strlen(i->buffer) + 0] = c;
  }

  i->last = c;
  i->state.pos++;
  i->state.col++;

  if (c == '\n') {
    i->state.col = 0;
    i->state.row++;
  }

  if (o) {
    (*o) = mpc_malloc(i, 2);
    (*o)[0] = c;
    (*o)[1] = '\0';
  }

  return 1;
}

static int mpc_input_any(mpc_input_t *i, char **o) {
  char x;
  if (mpc_input_terminated(i)) { return 0; }
  x = mpc_input_getc(i);
  return mpc_input_success(i, x, o);
}

static int mpc_input_char(mpc_input_t *i, char c, char **o) {
  char x;
  if (mpc_input_terminated(i)) { return 0; }
  x = mpc_input_getc(i);
  return x == c ? mpc_input_success(i, x, o) : mpc_input_failure(i, x);
}

static int mpc_input_range(mpc_input_t *i, char c, char d, char **o) {
  char x;
  if (mpc_input_terminated(i)) { return 0; }
  x = mpc_input_getc(i);
  return x >= c && x <= d ? mpc_input_success(i, x, o) : mpc_input_failure(i, x);
}

static int mpc_input_oneof(mpc_input_t *i, const char *c, char **o) {
  char x;
  if (mpc_input_terminated(i)) { return 0; }
  x = mpc_input_getc(i);
  return strchr(c, x) != 0 ? mpc_input_success(i, x, o) : mpc_input_failure(i, x);
}

static int mpc_input_noneof(mpc_input_t *i, const char *c, char **o) {
  char x;
  if (mpc_input_terminated(i)) { return 0; }
  x = mpc_input_getc(i);
  return strchr(c, x) == 0 ? mpc_input_success(i, x, o) : mpc_input_failure(i, x);
}

static int mpc_input_satisfy(mpc_input_t *i, int(*cond)(char), char **o) {
  char x;
  if (mpc_input_terminated(i)) { return 0; }
  x = mpc_input_getc(i);
  return cond(x) ? mpc_input_success(i, x, o) : mpc_input_failure(i, x);
}

static int mpc_input_string(mpc_input_t *i, const char *c, char **o) {

  const char *x = c;

  mpc_input_mark(i);
  while (*x) {
    if (!mpc_input_char(i, *x, ((void *)0))) {
      mpc_input_rewind(i);
      return 0;
    }
    x++;
  }
  mpc_input_unmark(i);

  *o = mpc_malloc(i, strlen(c) + 1);
  strcpy(*o, c);
  return 1;
}

static int mpc_input_anchor(mpc_input_t* i, int(*f)(char,char), char **o) {
  *o = ((void *)0);
  return f(i->last, mpc_input_peekc(i));
}

static int mpc_input_soi(mpc_input_t* i, char **o) {
  *o = ((void *)0);
  return i->last == '\0';
}

static int mpc_input_eoi(mpc_input_t* i, char **o) {
  *o = ((void *)0);
  if (i->state.term) {
    return 0;
  } else if (mpc_input_terminated(i)) {
    i->state.term = 1;
    return 1;
  } else {
    return 0;
  }
}

static mpc_state_t *mpc_input_state_copy(mpc_input_t *i) {
  mpc_state_t *r = mpc_malloc(i, sizeof(mpc_state_t));
  memcpy(r, &i->state, sizeof(mpc_state_t));
  return r;
}

/*
** Error Type
*/

void mpc_err_delete(mpc_err_t *x) {
  int i;
  for (i = 0; i < x->expected_num; i++) { free(x->expected[i]); }
  free(x->expected);
  free(x->filename);
  free(x->failure);
  free(x);
}

void mpc_err_print(mpc_err_t *x) {
  mpc_err_print_to(x, (&_iob[1]));
}

void mpc_err_print_to(mpc_err_t *x, FILE *f) {
  char *str = mpc_err_string(x);
  fprintf(f, "%s", str);
  free(str);
}

static void mpc_err_string_cat(char *buffer, int *pos, int *max, char const *fmt, ...) {
  /* TODO: Error Checking on Length */
  int left = ((*max) - (*pos));
  va_list va;
  ((void)((va) = (va_list)&(fmt)+((sizeof(fmt) + 3) & ~3)));
  if (left < 0) { left = 0;}
  (*pos) += vsprintf(buffer + (*pos), fmt, va);
  ((void)0);
}

static char char_unescape_buffer[4];

static const char *mpc_err_char_unescape(char c) {

  char_unescape_buffer[0] = '\'';
  char_unescape_buffer[1] = ' ';
  char_unescape_buffer[2] = '\'';
  char_unescape_buffer[3] = '\0';

  switch (c) {
    case '\a': return "bell";
    case '\b': return "backspace";
    case '\f': return "formfeed";
    case '\r': return "carriage return";
    case '\v': return "vertical tab";
    case '\0': return "end of input";
    case '\n': return "newline";
    case '\t': return "tab";
    case ' ' : return "space";
    default:
      char_unescape_buffer[1] = c;
      return char_unescape_buffer;
  }

}

char *mpc_err_string(mpc_err_t *x) {

  int i;
  int pos = 0;
  int max = 1023;
  char *buffer = calloc(1, 1024);

  if (x->failure) {
    mpc_err_string_cat(buffer, &pos, &max,
    "%s: error: %s\n", x->filename, x->failure);
    return buffer;
  }

  mpc_err_string_cat(buffer, &pos, &max,
    "%s:%li:%li: error: expected ", x->filename, x->state.row+1, x->state.col+1);

  if (x->expected_num == 0) { mpc_err_string_cat(buffer, &pos, &max, "ERROR: NOTHING EXPECTED"); }
  if (x->expected_num == 1) { mpc_err_string_cat(buffer, &pos, &max, "%s", x->expected[0]); }
  if (x->expected_num >= 2) {

    for (i = 0; i < x->expected_num-2; i++) {
      mpc_err_string_cat(buffer, &pos, &max, "%s, ", x->expected[i]);
    }

    mpc_err_string_cat(buffer, &pos, &max, "%s or %s",
      x->expected[x->expected_num-2],
      x->expected[x->expected_num-1]);
  }

  mpc_err_string_cat(buffer, &pos, &max, " at ");
  mpc_err_string_cat(buffer, &pos, &max, mpc_err_char_unescape(x->received));
  mpc_err_string_cat(buffer, &pos, &max, "\n");

  return realloc(buffer, strlen(buffer) + 1);
}

static mpc_err_t *mpc_err_new(mpc_input_t *i, const char *expected) {
  mpc_err_t *x;
  if (i->suppress) { return ((void *)0); }
  x = mpc_malloc(i, sizeof(mpc_err_t));
  x->filename = mpc_malloc(i, strlen(i->filename) + 1);
  strcpy(x->filename, i->filename);
  x->state = i->state;
  x->expected_num = 1;
  x->expected = mpc_malloc(i, sizeof(char*));
  x->expected[0] = mpc_malloc(i, strlen(expected) + 1);
  strcpy(x->expected[0], expected);
  x->failure = ((void *)0);
  x->received = mpc_input_peekc(i);
  return x;
}

static mpc_err_t *mpc_err_fail(mpc_input_t *i, const char *failure) {
  mpc_err_t *x;
  if (i->suppress) { return ((void *)0); }
  x = mpc_malloc(i, sizeof(mpc_err_t));
  x->filename = mpc_malloc(i, strlen(i->filename) + 1);
  strcpy(x->filename, i->filename);
  x->state = i->state;
  x->expected_num = 0;
  x->expected = ((void *)0);
  x->failure = mpc_malloc(i, strlen(failure) + 1);
  strcpy(x->failure, failure);
  x->received = ' ';
  return x;
}

static mpc_err_t *mpc_err_file(const char *filename, const char *failure) {
  mpc_err_t *x;
  x = malloc(sizeof(mpc_err_t));
  x->filename = malloc(strlen(filename) + 1);
  strcpy(x->filename, filename);
  x->state = mpc_state_new();
  x->expected_num = 0;
  x->expected = ((void *)0);
  x->failure = malloc(strlen(failure) + 1);
  strcpy(x->failure, failure);
  x->received = ' ';
  return x;
}

static void mpc_err_delete_internal(mpc_input_t *i, mpc_err_t *x) {
  int j;
  if (x == ((void *)0)) { return; }
  for (j = 0; j < x->expected_num; j++) { mpc_free(i, x->expected[j]); }
  mpc_free(i, x->expected);
  mpc_free(i, x->filename);
  mpc_free(i, x->failure);
  mpc_free(i, x);
}

static mpc_err_t *mpc_err_export(mpc_input_t *i, mpc_err_t *x) {
  int j;
  for (j = 0; j < x->expected_num; j++) {
    x->expected[j] = mpc_export(i, x->expected[j]);
  }
  x->expected = mpc_export(i, x->expected);
  x->filename = mpc_export(i, x->filename);
  x->failure = mpc_export(i, x->failure);
  return mpc_export(i, x);
}

static int mpc_err_contains_expected(mpc_input_t *i, mpc_err_t *x, char *expected) {
  int j;
  (void)i;
  for (j = 0; j < x->expected_num; j++) {
    if (strcmp(x->expected[j], expected) == 0) { return 1; }
  }
  return 0;
}

static void mpc_err_add_expected(mpc_input_t *i, mpc_err_t *x, char *expected) {
  (void)i;
  x->expected_num++;
  x->expected = mpc_realloc(i, x->expected, sizeof(char*) * x->expected_num);
  x->expected[x->expected_num-1] = mpc_malloc(i, strlen(expected) + 1);
  strcpy(x->expected[x->expected_num-1], expected);
}

static mpc_err_t *mpc_err_or(mpc_input_t *i, mpc_err_t** x, int n) {

  int j, k, fst;
  mpc_err_t *e;

  fst = -1;
  for (j = 0; j < n; j++) {
    if (x[j] != ((void *)0)) { fst = j; }
  }

  if (fst == -1) { return ((void *)0); }

  e = mpc_malloc(i, sizeof(mpc_err_t));
  e->state = mpc_state_invalid();
  e->expected_num = 0;
  e->expected = ((void *)0);
  e->failure = ((void *)0);
  e->filename = mpc_malloc(i, strlen(x[fst]->filename)+1);
  strcpy(e->filename, x[fst]->filename);

  for (j = 0; j < n; j++) {
    if (x[j] == ((void *)0)) { continue; }
    if (x[j]->state.pos > e->state.pos) { e->state = x[j]->state; }
  }

  for (j = 0; j < n; j++) {
    if (x[j] == ((void *)0)) { continue; }
    if (x[j]->state.pos < e->state.pos) { continue; }

    if (x[j]->failure) {
      e->failure = mpc_malloc(i, strlen(x[j]->failure)+1);
      strcpy(e->failure, x[j]->failure);
      break;
    }

    e->received = x[j]->received;

    for (k = 0; k < x[j]->expected_num; k++) {
      if (!mpc_err_contains_expected(i, e, x[j]->expected[k])) {
        mpc_err_add_expected(i, e, x[j]->expected[k]);
      }
    }
  }

  for (j = 0; j < n; j++) {
    if (x[j] == ((void *)0)) { continue; }
    mpc_err_delete_internal(i, x[j]);
  }

  return e;
}

static mpc_err_t *mpc_err_repeat(mpc_input_t *i, mpc_err_t *x, const char *prefix) {

  int j = 0;
  size_t l = 0;
  char *expect = ((void *)0);

  if (x == ((void *)0)) { return ((void *)0); }

  if (x->expected_num == 0) {
    expect = mpc_calloc(i, 1, 1);
    x->expected_num = 1;
    x->expected = mpc_realloc(i, x->expected, sizeof(char*) * x->expected_num);
    x->expected[0] = expect;
    return x;
  }

  else if (x->expected_num == 1) {
    expect = mpc_malloc(i, strlen(prefix) + strlen(x->expected[0]) + 1);
    strcpy(expect, prefix);
    strcat(expect, x->expected[0]);
    mpc_free(i, x->expected[0]);
    x->expected[0] = expect;
    return x;
  }

  else if (x->expected_num > 1) {

    l += strlen(prefix);
    for (j = 0; j < x->expected_num-2; j++) {
      l += strlen(x->expected[j]) + strlen(", ");
    }
    l += strlen(x->expected[x->expected_num-2]);
    l += strlen(" or ");
    l += strlen(x->expected[x->expected_num-1]);

    expect = mpc_malloc(i, l + 1);

    strcpy(expect, prefix);
    for (j = 0; j < x->expected_num-2; j++) {
      strcat(expect, x->expected[j]); strcat(expect, ", ");
    }
    strcat(expect, x->expected[x->expected_num-2]);
    strcat(expect, " or ");
    strcat(expect, x->expected[x->expected_num-1]);

    for (j = 0; j < x->expected_num; j++) { mpc_free(i, x->expected[j]); }

    x->expected_num = 1;
    x->expected = mpc_realloc(i, x->expected, sizeof(char*) * x->expected_num);
    x->expected[0] = expect;
    return x;
  }

  return ((void *)0);
}

static mpc_err_t *mpc_err_many1(mpc_input_t *i, mpc_err_t *x) {
  return mpc_err_repeat(i, x, "one or more of ");
}

static mpc_err_t *mpc_err_count(mpc_input_t *i, mpc_err_t *x, int n) {
  mpc_err_t *y;
  int digits = n/10 + 1;
  char *prefix;
  prefix = mpc_malloc(i, digits + strlen(" of ") + 1);
  sprintf(prefix, "%i of ", n);
  y = mpc_err_repeat(i, x, prefix);
  mpc_free(i, prefix);
  return y;
}

static mpc_err_t *mpc_err_merge(mpc_input_t *i, mpc_err_t *x, mpc_err_t *y) {
  mpc_err_t *errs[2];
  errs[0] = x;
  errs[1] = y;
  return mpc_err_or(i, errs, 2);
}

/*
** Parser Type
*/

enum {
  MPC_TYPE_UNDEFINED  = 0,
  MPC_TYPE_PASS       = 1,
  MPC_TYPE_FAIL       = 2,
  MPC_TYPE_LIFT       = 3,
  MPC_TYPE_LIFT_VAL   = 4,
  MPC_TYPE_EXPECT     = 5,
  MPC_TYPE_ANCHOR     = 6,
  MPC_TYPE_STATE      = 7,

  MPC_TYPE_ANY        = 8,
  MPC_TYPE_SINGLE     = 9,
  MPC_TYPE_ONEOF      = 10,
  MPC_TYPE_NONEOF     = 11,
  MPC_TYPE_RANGE      = 12,
  MPC_TYPE_SATISFY    = 13,
  MPC_TYPE_STRING     = 14,

  MPC_TYPE_APPLY      = 15,
  MPC_TYPE_APPLY_TO   = 16,
  MPC_TYPE_PREDICT    = 17,
  MPC_TYPE_NOT        = 18,
  MPC_TYPE_MAYBE      = 19,
  MPC_TYPE_MANY       = 20,
  MPC_TYPE_MANY1      = 21,
  MPC_TYPE_COUNT      = 22,

  MPC_TYPE_OR         = 23,
  MPC_TYPE_AND        = 24,

  MPC_TYPE_CHECK      = 25,
  MPC_TYPE_CHECK_WITH = 26,

  MPC_TYPE_SOI        = 27,
  MPC_TYPE_EOI        = 28
};

typedef struct { char *m; } mpc_pdata_fail_t;
typedef struct { mpc_ctor_t lf; void *x; } mpc_pdata_lift_t;
typedef struct { mpc_parser_t *x; char *m; } mpc_pdata_expect_t;
typedef struct { int(*f)(char,char); } mpc_pdata_anchor_t;
typedef struct { char x; } mpc_pdata_single_t;
typedef struct { char x; char y; } mpc_pdata_range_t;
typedef struct { int(*f)(char); } mpc_pdata_satisfy_t;
typedef struct { char *x; } mpc_pdata_string_t;
typedef struct { mpc_parser_t *x; mpc_apply_t f; } mpc_pdata_apply_t;
typedef struct { mpc_parser_t *x; mpc_apply_to_t f; void *d; } mpc_pdata_apply_to_t;
typedef struct { mpc_parser_t *x; mpc_dtor_t dx; mpc_check_t f; char *e; } mpc_pdata_check_t;
typedef struct { mpc_parser_t *x; mpc_dtor_t dx; mpc_check_with_t f; void *d; char *e; } mpc_pdata_check_with_t;
typedef struct { mpc_parser_t *x; } mpc_pdata_predict_t;
typedef struct { mpc_parser_t *x; mpc_dtor_t dx; mpc_ctor_t lf; } mpc_pdata_not_t;
typedef struct { int n; mpc_fold_t f; mpc_parser_t *x; mpc_dtor_t dx; } mpc_pdata_repeat_t;
typedef struct { int n; mpc_parser_t **xs; } mpc_pdata_or_t;
typedef struct { int n; mpc_fold_t f; mpc_parser_t **xs; mpc_dtor_t *dxs;  } mpc_pdata_and_t;

typedef union {
  mpc_pdata_fail_t fail;
  mpc_pdata_lift_t lift;
  mpc_pdata_expect_t expect;
  mpc_pdata_anchor_t anchor;
  mpc_pdata_single_t single;
  mpc_pdata_range_t range;
  mpc_pdata_satisfy_t satisfy;
  mpc_pdata_string_t string;
  mpc_pdata_apply_t apply;
  mpc_pdata_apply_to_t apply_to;
  mpc_pdata_check_t check;
  mpc_pdata_check_with_t check_with;
  mpc_pdata_predict_t predict;
  mpc_pdata_not_t not;
  mpc_pdata_repeat_t repeat;
  mpc_pdata_and_t and;
  mpc_pdata_or_t or;
} mpc_pdata_t;

struct mpc_parser_t {
  char *name;
  mpc_pdata_t data;
  char type;
  char retained;
};

static mpc_val_t *mpcf_input_nth_free(mpc_input_t *i, int n, mpc_val_t **xs, int x) {
  int j;
  for (j = 0; j < n; j++) { if (j != x) { mpc_free(i, xs[j]); } }
  return xs[x];
}

static mpc_val_t *mpcf_input_fst_free(mpc_input_t *i, int n, mpc_val_t **xs) { return mpcf_input_nth_free(i, n, xs, 0); }
static mpc_val_t *mpcf_input_snd_free(mpc_input_t *i, int n, mpc_val_t **xs) { return mpcf_input_nth_free(i, n, xs, 1); }
static mpc_val_t *mpcf_input_trd_free(mpc_input_t *i, int n, mpc_val_t **xs) { return mpcf_input_nth_free(i, n, xs, 2); }

static mpc_val_t *mpcf_input_strfold(mpc_input_t *i, int n, mpc_val_t **xs) {
  int j;
  size_t l = 0;
  if (n == 0) { return mpc_calloc(i, 1, 1); }
  for (j = 0; j < n; j++) { l += strlen(xs[j]); }
  xs[0] = mpc_realloc(i, xs[0], l + 1);
  for (j = 1; j < n; j++) { strcat(xs[0], xs[j]); mpc_free(i, xs[j]); }
  return xs[0];
}

static mpc_val_t *mpcf_input_state_ast(mpc_input_t *i, int n, mpc_val_t **xs) {
  mpc_state_t *s = ((mpc_state_t**)xs)[0];
  mpc_ast_t *a = ((mpc_ast_t**)xs)[1];
  a = mpc_ast_state(a, *s);
  mpc_free(i, s);
  (void) n;
  return a;
}

static mpc_val_t *mpc_parse_fold(mpc_input_t *i, mpc_fold_t f, int n, mpc_val_t **xs) {
  int j;
  if (f == mpcf_null)      { return mpcf_null(n, xs); }
  if (f == mpcf_fst)       { return mpcf_fst(n, xs); }
  if (f == mpcf_snd)       { return mpcf_snd(n, xs); }
  if (f == mpcf_trd)       { return mpcf_trd(n, xs); }
  if (f == mpcf_fst_free)  { return mpcf_input_fst_free(i, n, xs); }
  if (f == mpcf_snd_free)  { return mpcf_input_snd_free(i, n, xs); }
  if (f == mpcf_trd_free)  { return mpcf_input_trd_free(i, n, xs); }
  if (f == mpcf_strfold)   { return mpcf_input_strfold(i, n, xs); }
  if (f == mpcf_state_ast) { return mpcf_input_state_ast(i, n, xs); }
  for (j = 0; j < n; j++) { xs[j] = mpc_export(i, xs[j]); }
  return f(j, xs);
}

static mpc_val_t *mpcf_input_free(mpc_input_t *i, mpc_val_t *x) {
  mpc_free(i, x);
  return ((void *)0);
}

static mpc_val_t *mpcf_input_str_ast(mpc_input_t *i, mpc_val_t *c) {
  mpc_ast_t *a = mpc_ast_new("", c);
  mpc_free(i, c);
  return a;
}

static mpc_val_t *mpc_parse_apply(mpc_input_t *i, mpc_apply_t f, mpc_val_t *x) {
  if (f == mpcf_free)     { return mpcf_input_free(i, x); }
  if (f == mpcf_str_ast)  { return mpcf_input_str_ast(i, x); }
  return f(mpc_export(i, x));
}

static mpc_val_t *mpc_parse_apply_to(mpc_input_t *i, mpc_apply_to_t f, mpc_val_t *x, mpc_val_t *d) {
  return f(mpc_export(i, x), d);
}

static void mpc_parse_dtor(mpc_input_t *i, mpc_dtor_t d, mpc_val_t *x) {
  if (d == free) { mpc_free(i, x); return; }
  d(mpc_export(i, x));
}

enum {
  MPC_PARSE_STACK_MIN = 4
};

#define MPC_SUCCESS(x) r->output = x; return 1
#define MPC_FAILURE(x) r->error = x; return 0
#define MPC_PRIMITIVE(x)   if (x) { MPC_SUCCESS(r->output); }   else { MPC_FAILURE(NULL); }

#define MPC_MAX_RECURSION_DEPTH 1000

static int mpc_parse_run(mpc_input_t *i, mpc_parser_t *p, mpc_result_t *r, mpc_err_t **e, int depth) {

  int j = 0, k = 0;
  mpc_result_t results_stk[MPC_PARSE_STACK_MIN];
  mpc_result_t *results;
  int results_slots = MPC_PARSE_STACK_MIN;

  if (depth == 1000)
  {
    r->error = mpc_err_fail(i, "Maximum recursion depth exceeded!"); return 0;
  }

  switch (p->type) {

    /* Basic Parsers */

    case MPC_TYPE_ANY:     if (mpc_input_any(i, (char**)&r->output)) { r->output = r->output; return 1; } else { r->error = ((void *)0); return 0; };
    case MPC_TYPE_SINGLE:  if (mpc_input_char(i, p->data.single.x, (char**)&r->output)) { r->output = r->output; return 1; } else { r->error = ((void *)0); return 0; };
    case MPC_TYPE_RANGE:   if (mpc_input_range(i, p->data.range.x, p->data.range.y, (char**)&r->output)) { r->output = r->output; return 1; } else { r->error = ((void *)0); return 0; };
    case MPC_TYPE_ONEOF:   if (mpc_input_oneof(i, p->data.string.x, (char**)&r->output)) { r->output = r->output; return 1; } else { r->error = ((void *)0); return 0; };
    case MPC_TYPE_NONEOF:  if (mpc_input_noneof(i, p->data.string.x, (char**)&r->output)) { r->output = r->output; return 1; } else { r->error = ((void *)0); return 0; };
    case MPC_TYPE_SATISFY: if (mpc_input_satisfy(i, p->data.satisfy.f, (char**)&r->output)) { r->output = r->output; return 1; } else { r->error = ((void *)0); return 0; };
    case MPC_TYPE_STRING:  if (mpc_input_string(i, p->data.string.x, (char**)&r->output)) { r->output = r->output; return 1; } else { r->error = ((void *)0); return 0; };
    case MPC_TYPE_ANCHOR:  if (mpc_input_anchor(i, p->data.anchor.f, (char**)&r->output)) { r->output = r->output; return 1; } else { r->error = ((void *)0); return 0; };
    case MPC_TYPE_SOI:     if (mpc_input_soi(i, (char**)&r->output)) { r->output = r->output; return 1; } else { r->error = ((void *)0); return 0; };
    case MPC_TYPE_EOI:     if (mpc_input_eoi(i, (char**)&r->output)) { r->output = r->output; return 1; } else { r->error = ((void *)0); return 0; };

    /* Other parsers */

    case MPC_TYPE_UNDEFINED: r->error = mpc_err_fail(i, "Parser Undefined!"); return 0;
    case MPC_TYPE_PASS:      r->output = ((void *)0); return 1;
    case MPC_TYPE_FAIL:      r->error = mpc_err_fail(i, p->data.fail.m); return 0;
    case MPC_TYPE_LIFT:      r->output = p->data.lift.lf(); return 1;
    case MPC_TYPE_LIFT_VAL:  r->output = p->data.lift.x; return 1;
    case MPC_TYPE_STATE:     r->output = mpc_input_state_copy(i); return 1;

    /* Application Parsers */

    case MPC_TYPE_APPLY:
      if (mpc_parse_run(i, p->data.apply.x, r, e, depth+1)) {
        r->output = mpc_parse_apply(i, p->data.apply.f, r->output); return 1;
      } else {
        r->error = r->output; return 0;
      }

    case MPC_TYPE_APPLY_TO:
      if (mpc_parse_run(i, p->data.apply_to.x, r, e, depth+1)) {
        r->output = mpc_parse_apply_to(i, p->data.apply_to.f, r->output, p->data.apply_to.d); return 1;
      } else {
        r->error = r->error; return 0;
      }

    case MPC_TYPE_CHECK:
      if (mpc_parse_run(i, p->data.check.x, r, e, depth+1)) {
        if (p->data.check.f(&r->output)) {
          r->output = r->output; return 1;
        } else {
          mpc_parse_dtor(i, p->data.check.dx, r->output);
          r->error = mpc_err_fail(i, p->data.check.e); return 0;
        }
      } else {
        r->error = r->error; return 0;
      }

    case MPC_TYPE_CHECK_WITH:
      if (mpc_parse_run(i, p->data.check_with.x, r, e, depth+1)) {
        if (p->data.check_with.f(&r->output, p->data.check_with.d)) {
          r->output = r->output; return 1;
        } else {
          mpc_parse_dtor(i, p->data.check.dx, r->output);
          r->error = mpc_err_fail(i, p->data.check_with.e); return 0;
        }
      } else {
        r->error = r->error; return 0;
      }

    case MPC_TYPE_EXPECT:
      mpc_input_suppress_enable(i);
      if (mpc_parse_run(i, p->data.expect.x, r, e, depth+1)) {
        mpc_input_suppress_disable(i);
        r->output = r->output; return 1;
      } else {
        mpc_input_suppress_disable(i);
        r->error = mpc_err_new(i, p->data.expect.m); return 0;
      }

    case MPC_TYPE_PREDICT:
      mpc_input_backtrack_disable(i);
      if (mpc_parse_run(i, p->data.predict.x, r, e, depth+1)) {
        mpc_input_backtrack_enable(i);
        r->output = r->output; return 1;
      } else {
        mpc_input_backtrack_enable(i);
        r->error = r->error; return 0;
      }

    /* Optional Parsers */

    /* TODO: Update Not Error Message */

    case MPC_TYPE_NOT:
      mpc_input_mark(i);
      mpc_input_suppress_enable(i);
      if (mpc_parse_run(i, p->data.not.x, r, e, depth+1)) {
        mpc_input_rewind(i);
        mpc_input_suppress_disable(i);
        mpc_parse_dtor(i, p->data.not.dx, r->output);
        r->error = mpc_err_new(i, "opposite"); return 0;
      } else {
        mpc_input_unmark(i);
        mpc_input_suppress_disable(i);
        r->output = p->data.not.lf(); return 1;
      }

    case MPC_TYPE_MAYBE:
      if (mpc_parse_run(i, p->data.not.x, r, e, depth+1)) {
        r->output = r->output; return 1;
      } else {
        *e = mpc_err_merge(i, *e, r->error);
        r->output = p->data.not.lf(); return 1;
      }

    /* Repeat Parsers */

    case MPC_TYPE_MANY:

      results = results_stk;

      while (mpc_parse_run(i, p->data.repeat.x, &results[j], e, depth+1)) {
        j++;
        if (j == MPC_PARSE_STACK_MIN) {
          results_slots = j + j / 2;
          results = mpc_malloc(i, sizeof(mpc_result_t) * results_slots);
          memcpy(results, results_stk, sizeof(mpc_result_t) * MPC_PARSE_STACK_MIN);
        } else if (j >= results_slots) {
          results_slots = j + j / 2;
          results = mpc_realloc(i, results, sizeof(mpc_result_t) * results_slots);
        }
      }

      *e = mpc_err_merge(i, *e, results[j].error);

      r->output = mpc_parse_fold(i, p->data.repeat.f, j, (mpc_val_t**)results); if (j >= MPC_PARSE_STACK_MIN) { mpc_free(i, results); }; return 1;

    case MPC_TYPE_MANY1:

      results = results_stk;

      while (mpc_parse_run(i, p->data.repeat.x, &results[j], e, depth+1)) {
        j++;
        if (j == MPC_PARSE_STACK_MIN) {
          results_slots = j + j / 2;
          results = mpc_malloc(i, sizeof(mpc_result_t) * results_slots);
          memcpy(results, results_stk, sizeof(mpc_result_t) * MPC_PARSE_STACK_MIN);
        } else if (j >= results_slots) {
          results_slots = j + j / 2;
          results = mpc_realloc(i, results, sizeof(mpc_result_t) * results_slots);
        }
      }

      if (j == 0) {
        r->error = mpc_err_many1(i, results[j].error); if (j >= MPC_PARSE_STACK_MIN) { mpc_free(i, results); }; return 0;
      } else {

        *e = mpc_err_merge(i, *e, results[j].error);

        r->output = mpc_parse_fold(i, p->data.repeat.f, j, (mpc_val_t**)results); if (j >= MPC_PARSE_STACK_MIN) { mpc_free(i, results); }; return 1;
      }

    case MPC_TYPE_COUNT:

      results = p->data.repeat.n > MPC_PARSE_STACK_MIN
        ? mpc_malloc(i, sizeof(mpc_result_t) * p->data.repeat.n)
        : results_stk;

      while (mpc_parse_run(i, p->data.repeat.x, &results[j], e, depth+1)) {
        j++;
        if (j == p->data.repeat.n) { break; }
      }

      if (j == p->data.repeat.n) {
        r->output = mpc_parse_fold(i, p->data.repeat.f, j, (mpc_val_t**)results); if (p->data.repeat.n > MPC_PARSE_STACK_MIN) { mpc_free(i, results); }; return 1;
      } else {
        for (k = 0; k < j; k++) {
          mpc_parse_dtor(i, p->data.repeat.dx, results[k].output);
        }
        r->error = mpc_err_count(i, results[j].error, p->data.repeat.n); if (p->data.repeat.n > MPC_PARSE_STACK_MIN) { mpc_free(i, results); }; return 0;
      }

    /* Combinatory Parsers */

    case MPC_TYPE_OR:

      if (p->data.or.n == 0) { r->output = ((void *)0); return 1; }

      results = p->data.or.n > MPC_PARSE_STACK_MIN
        ? mpc_malloc(i, sizeof(mpc_result_t) * p->data.or.n)
        : results_stk;

      for (j = 0; j < p->data.or.n; j++) {
        if (mpc_parse_run(i, p->data.or.xs[j], &results[j], e, depth+1)) {
          r->output = results[j].output; if (p->data.or.n > MPC_PARSE_STACK_MIN) { mpc_free(i, results); }; return 1;
        } else {
          *e = mpc_err_merge(i, *e, results[j].error);
        }
      }

      r->error = ((void *)0); if (p->data.or.n > MPC_PARSE_STACK_MIN) { mpc_free(i, results); }; return 0;

    case MPC_TYPE_AND:

      if (p->data.and.n == 0) { r->output = ((void *)0); return 1; }

      results = p->data.or.n > MPC_PARSE_STACK_MIN
        ? mpc_malloc(i, sizeof(mpc_result_t) * p->data.or.n)
        : results_stk;

      mpc_input_mark(i);
      for (j = 0; j < p->data.and.n; j++) {
        if (!mpc_parse_run(i, p->data.and.xs[j], &results[j], e, depth+1)) {
          mpc_input_rewind(i);
          for (k = 0; k < j; k++) {
            mpc_parse_dtor(i, p->data.and.dxs[k], results[k].output);
          }
          r->error = results[j].error; if (p->data.or.n > MPC_PARSE_STACK_MIN) { mpc_free(i, results); }; return 0;
        }
      }
      mpc_input_unmark(i);
      r->output = mpc_parse_fold(i, p->data.and.f, j, (mpc_val_t**)results); if (p->data.or.n > MPC_PARSE_STACK_MIN) { mpc_free(i, results); }; return 1;

    /* End */

    default:

      r->error = mpc_err_fail(i, "Unknown Parser Type Id!"); return 0;
  }

  return 0;

}

#undef MPC_SUCCESS
#undef MPC_FAILURE
#undef MPC_PRIMITIVE

int mpc_parse_input(mpc_input_t *i, mpc_parser_t *p, mpc_result_t *r) {
  int x;
  mpc_err_t *e = mpc_err_fail(i, "Unknown Error");
  e->state = mpc_state_invalid();
  x = mpc_parse_run(i, p, r, &e, 0);
  if (x) {
    mpc_err_delete_internal(i, e);
    r->output = mpc_export(i, r->output);
  } else {
    r->error = mpc_err_export(i, mpc_err_merge(i, e, r->error));
  }
  return x;
}

int mpc_parse(const char *filename, const char *string, mpc_parser_t *p, mpc_result_t *r) {
  int x;
  mpc_input_t *i = mpc_input_new_string(filename, string);
  x = mpc_parse_input(i, p, r);
  mpc_input_delete(i);
  return x;
}

int mpc_nparse(const char *filename, const char *string, size_t length, mpc_parser_t *p, mpc_result_t *r) {
  int x;
  mpc_input_t *i = mpc_input_new_nstring(filename, string, length);
  x = mpc_parse_input(i, p, r);
  mpc_input_delete(i);
  return x;
}

int mpc_parse_file(const char *filename, FILE *file, mpc_parser_t *p, mpc_result_t *r) {
  int x;
  mpc_input_t *i = mpc_input_new_file(filename, file);
  x = mpc_parse_input(i, p, r);
  mpc_input_delete(i);
  return x;
}

int mpc_parse_pipe(const char *filename, FILE *pipe, mpc_parser_t *p, mpc_result_t *r) {
  int x;
  mpc_input_t *i = mpc_input_new_pipe(filename, pipe);
  x = mpc_parse_input(i, p, r);
  mpc_input_delete(i);
  return x;
}

int mpc_parse_contents(const char *filename, mpc_parser_t *p, mpc_result_t *r) {

  FILE *f = fopen(filename, "rb");
  int res;

  if (f == ((void *)0)) {
    r->output = ((void *)0);
    r->error = mpc_err_file(filename, "Unable to open file!");
    return 0;
  }

  res = mpc_parse_file(filename, f, p, r);
  fclose(f);
  return res;
}

/*
** Building a Parser
*/

static void mpc_undefine_unretained(mpc_parser_t *p, int force);

static void mpc_undefine_or(mpc_parser_t *p) {

  int i;
  for (i = 0; i < p->data.or.n; i++) {
    mpc_undefine_unretained(p->data.or.xs[i], 0);
  }
  free(p->data.or.xs);

}

static void mpc_undefine_and(mpc_parser_t *p) {

  int i;
  for (i = 0; i < p->data.and.n; i++) {
    mpc_undefine_unretained(p->data.and.xs[i], 0);
  }
  free(p->data.and.xs);
  free(p->data.and.dxs);

}

static void mpc_undefine_unretained(mpc_parser_t *p, int force) {

  if (p->retained && !force) { return; }

  switch (p->type) {

    case MPC_TYPE_FAIL: free(p->data.fail.m); break;

    case MPC_TYPE_ONEOF:
    case MPC_TYPE_NONEOF:
    case MPC_TYPE_STRING:
      free(p->data.string.x);
      break;

    case MPC_TYPE_APPLY:    mpc_undefine_unretained(p->data.apply.x, 0);    break;
    case MPC_TYPE_APPLY_TO: mpc_undefine_unretained(p->data.apply_to.x, 0); break;
    case MPC_TYPE_PREDICT:  mpc_undefine_unretained(p->data.predict.x, 0);  break;

    case MPC_TYPE_MAYBE:
    case MPC_TYPE_NOT:
      mpc_undefine_unretained(p->data.not.x, 0);
      break;

    case MPC_TYPE_EXPECT:
      mpc_undefine_unretained(p->data.expect.x, 0);
      free(p->data.expect.m);
      break;

    case MPC_TYPE_MANY:
    case MPC_TYPE_MANY1:
    case MPC_TYPE_COUNT:
      mpc_undefine_unretained(p->data.repeat.x, 0);
      break;

    case MPC_TYPE_OR:  mpc_undefine_or(p);  break;
    case MPC_TYPE_AND: mpc_undefine_and(p); break;

    case MPC_TYPE_CHECK:
      mpc_undefine_unretained(p->data.check.x, 0);
      free(p->data.check.e);
      break;

    case MPC_TYPE_CHECK_WITH:
      mpc_undefine_unretained(p->data.check_with.x, 0);
      free(p->data.check_with.e);
      break;

    default: break;
  }

  if (!force) {
    free(p->name);
    free(p);
  }

}

void mpc_delete(mpc_parser_t *p) {
  if (p->retained) {

    if (p->type != MPC_TYPE_UNDEFINED) {
      mpc_undefine_unretained(p, 0);
    }

    free(p->name);
    free(p);

  } else {
    mpc_undefine_unretained(p, 0);
  }
}

static void mpc_soft_delete(mpc_val_t *x) {
  mpc_undefine_unretained(x, 0);
}

static mpc_parser_t *mpc_undefined(void) {
  mpc_parser_t *p = calloc(1, sizeof(mpc_parser_t));
  p->retained = 0;
  p->type = MPC_TYPE_UNDEFINED;
  p->name = ((void *)0);
  return p;
}

mpc_parser_t *mpc_new(const char *name) {
  mpc_parser_t *p = mpc_undefined();
  p->retained = 1;
  p->name = realloc(p->name, strlen(name) + 1);
  strcpy(p->name, name);
  return p;
}

mpc_parser_t *mpc_copy(mpc_parser_t *a) {
  int i = 0;
  mpc_parser_t *p;

  if (a->retained) { return a; }

  p = mpc_undefined();
  p->retained = a->retained;
  p->type = a->type;
  p->data = a->data;

  if (a->name) {
    p->name = malloc(strlen(a->name)+1);
    strcpy(p->name, a->name);
  }

  switch (a->type) {

    case MPC_TYPE_FAIL:
      p->data.fail.m = malloc(strlen(a->data.fail.m)+1);
      strcpy(p->data.fail.m, a->data.fail.m);
    break;

    case MPC_TYPE_ONEOF:
    case MPC_TYPE_NONEOF:
    case MPC_TYPE_STRING:
      p->data.string.x = malloc(strlen(a->data.string.x)+1);
      strcpy(p->data.string.x, a->data.string.x);
      break;

    case MPC_TYPE_APPLY:    p->data.apply.x    = mpc_copy(a->data.apply.x);    break;
    case MPC_TYPE_APPLY_TO: p->data.apply_to.x = mpc_copy(a->data.apply_to.x); break;
    case MPC_TYPE_PREDICT:  p->data.predict.x  = mpc_copy(a->data.predict.x);  break;

    case MPC_TYPE_MAYBE:
    case MPC_TYPE_NOT:
      p->data.not.x = mpc_copy(a->data.not.x);
      break;

    case MPC_TYPE_EXPECT:
      p->data.expect.x = mpc_copy(a->data.expect.x);
      p->data.expect.m = malloc(strlen(a->data.expect.m)+1);
      strcpy(p->data.expect.m, a->data.expect.m);
      break;

    case MPC_TYPE_MANY:
    case MPC_TYPE_MANY1:
    case MPC_TYPE_COUNT:
      p->data.repeat.x = mpc_copy(a->data.repeat.x);
      break;

    case MPC_TYPE_OR:
      p->data.or.xs = malloc(a->data.or.n * sizeof(mpc_parser_t*));
      for (i = 0; i < a->data.or.n; i++) {
        p->data.or.xs[i] = mpc_copy(a->data.or.xs[i]);
      }
    break;
    case MPC_TYPE_AND:
      p->data.and.xs = malloc(a->data.and.n * sizeof(mpc_parser_t*));
      for (i = 0; i < a->data.and.n; i++) {
        p->data.and.xs[i] = mpc_copy(a->data.and.xs[i]);
      }
      p->data.and.dxs = malloc((a->data.and.n-1) * sizeof(mpc_dtor_t));
      for (i = 0; i < a->data.and.n-1; i++) {
        p->data.and.dxs[i] = a->data.and.dxs[i];
      }
    break;

    case MPC_TYPE_CHECK:
      p->data.check.x      = mpc_copy(a->data.check.x);
      p->data.check.e      = malloc(strlen(a->data.check.e)+1);
      strcpy(p->data.check.e, a->data.check.e);
      break;
    case MPC_TYPE_CHECK_WITH:
      p->data.check_with.x = mpc_copy(a->data.check_with.x);
      p->data.check_with.e = malloc(strlen(a->data.check_with.e)+1);
      strcpy(p->data.check_with.e, a->data.check_with.e);
      break;

    default: break;
  }


  return p;
}

mpc_parser_t *mpc_undefine(mpc_parser_t *p) {
  mpc_undefine_unretained(p, 1);
  p->type = MPC_TYPE_UNDEFINED;
  return p;
}

mpc_parser_t *mpc_define(mpc_parser_t *p, mpc_parser_t *a) {

  if (p->retained) {
    p->type = a->type;
    p->data = a->data;
  } else {
    mpc_parser_t *a2 = mpc_failf("Attempt to assign to Unretained Parser!");
    p->type = a2->type;
    p->data = a2->data;
    free(a2);
  }

  free(a);
  return p;
}

void mpc_cleanup(int n, ...) {
  int i;
  mpc_parser_t **list = malloc(sizeof(mpc_parser_t*) * n);

  va_list va;
  ((void)((va) = (va_list)&(n)+((sizeof(n) + 3) & ~3)));
  for (i = 0; i < n; i++) { list[i] = (*(mpc_parser_t*  *)(((va)+=((sizeof(mpc_parser_t*) + 3) & ~3))-(((sizeof(mpc_parser_t*) + 3) & ~3)))); }
  for (i = 0; i < n; i++) { mpc_undefine(list[i]); }
  for (i = 0; i < n; i++) { mpc_delete(list[i]); }
  ((void)0);

  free(list);
}

mpc_parser_t *mpc_pass(void) {
  mpc_parser_t *p = mpc_undefined();
  p->type = MPC_TYPE_PASS;
  return p;
}

mpc_parser_t *mpc_fail(const char *m) {
  mpc_parser_t *p = mpc_undefined();
  p->type = MPC_TYPE_FAIL;
  p->data.fail.m = malloc(strlen(m) + 1);
  strcpy(p->data.fail.m, m);
  return p;
}

/*
** As `snprintf` is not ANSI standard this
** function `mpc_failf` should be considered
** unsafe.
**
** You have a few options if this is going to be
** trouble.
**
** - Ensure the format string does not exceed
**   the buffer length using precision specifiers
**   such as `%.512s`.
**
** - Patch this function in your code base to
**   use `snprintf` or whatever variant your
**   system supports.
**
** - Avoid it altogether.
**
*/

mpc_parser_t *mpc_failf(const char *fmt, ...) {

  va_list va;
  char *buffer;

  mpc_parser_t *p = mpc_undefined();
  p->type = MPC_TYPE_FAIL;

  ((void)((va) = (va_list)&(fmt)+((sizeof(fmt) + 3) & ~3)));
  buffer = malloc(2048);
  vsprintf(buffer, fmt, va);
  ((void)0);

  buffer = realloc(buffer, strlen(buffer) + 1);
  p->data.fail.m = buffer;
  return p;

}

mpc_parser_t *mpc_lift_val(mpc_val_t *x) {
  mpc_parser_t *p = mpc_undefined();
  p->type = MPC_TYPE_LIFT_VAL;
  p->data.lift.x = x;
  return p;
}

mpc_parser_t *mpc_lift(mpc_ctor_t lf) {
  mpc_parser_t *p = mpc_undefined();
  p->type = MPC_TYPE_LIFT;
  p->data.lift.lf = lf;
  return p;
}

mpc_parser_t *mpc_anchor(int(*f)(char,char)) {
  mpc_parser_t *p = mpc_undefined();
  p->type = MPC_TYPE_ANCHOR;
  p->data.anchor.f = f;
  return mpc_expect(p, "anchor");
}

mpc_parser_t *mpc_state(void) {
  mpc_parser_t *p = mpc_undefined();
  p->type = MPC_TYPE_STATE;
  return p;
}

mpc_parser_t *mpc_expect(mpc_parser_t *a, const char *expected) {
  mpc_parser_t *p = mpc_undefined();
  p->type = MPC_TYPE_EXPECT;
  p->data.expect.x = a;
  p->data.expect.m = malloc(strlen(expected) + 1);
  strcpy(p->data.expect.m, expected);
  return p;
}

/*
** As `snprintf` is not ANSI standard this
** function `mpc_expectf` should be considered
** unsafe.
**
** You have a few options if this is going to be
** trouble.
**
** - Ensure the format string does not exceed
**   the buffer length using precision specifiers
**   such as `%.512s`.
**
** - Patch this function in your code base to
**   use `snprintf` or whatever variant your
**   system supports.
**
** - Avoid it altogether.
**
*/

mpc_parser_t *mpc_expectf(mpc_parser_t *a, const char *fmt, ...) {
  va_list va;
  char *buffer;

  mpc_parser_t *p = mpc_undefined();
  p->type = MPC_TYPE_EXPECT;

  ((void)((va) = (va_list)&(fmt)+((sizeof(fmt) + 3) & ~3)));
  buffer = malloc(2048);
  vsprintf(buffer, fmt, va);
  ((void)0);

  buffer = realloc(buffer, strlen(buffer) + 1);
  p->data.expect.x = a;
  p->data.expect.m = buffer;
  return p;
}

/*
** Basic Parsers
*/

mpc_parser_t *mpc_any(void) {
  mpc_parser_t *p = mpc_undefined();
  p->type = MPC_TYPE_ANY;
  return mpc_expect(p, "any character");
}

mpc_parser_t *mpc_char(char c) {
  mpc_parser_t *p = mpc_undefined();
  p->type = MPC_TYPE_SINGLE;
  p->data.single.x = c;
  return mpc_expectf(p, "'%c'", c);
}

mpc_parser_t *mpc_range(char s, char e) {
  mpc_parser_t *p = mpc_undefined();
  p->type = MPC_TYPE_RANGE;
  p->data.range.x = s;
  p->data.range.y = e;
  return mpc_expectf(p, "character between '%c' and '%c'", s, e);
}

mpc_parser_t *mpc_oneof(const char *s) {
  mpc_parser_t *p = mpc_undefined();
  p->type = MPC_TYPE_ONEOF;
  p->data.string.x = malloc(strlen(s) + 1);
  strcpy(p->data.string.x, s);
  return mpc_expectf(p, "one of '%s'", s);
}

mpc_parser_t *mpc_noneof(const char *s) {
  mpc_parser_t *p = mpc_undefined();
  p->type = MPC_TYPE_NONEOF;
  p->data.string.x = malloc(strlen(s) + 1);
  strcpy(p->data.string.x, s);
  return mpc_expectf(p, "none of '%s'", s);

}

mpc_parser_t *mpc_satisfy(int(*f)(char)) {
  mpc_parser_t *p = mpc_undefined();
  p->type = MPC_TYPE_SATISFY;
  p->data.satisfy.f = f;
  return mpc_expectf(p, "character satisfying function %p", f);
}

mpc_parser_t *mpc_string(const char *s) {
  mpc_parser_t *p = mpc_undefined();
  p->type = MPC_TYPE_STRING;
  p->data.string.x = malloc(strlen(s) + 1);
  strcpy(p->data.string.x, s);
  return mpc_expectf(p, "\"%s\"", s);
}

/*
** Core Parsers
*/

mpc_parser_t *mpc_apply(mpc_parser_t *a, mpc_apply_t f) {
  mpc_parser_t *p = mpc_undefined();
  p->type = MPC_TYPE_APPLY;
  p->data.apply.x = a;
  p->data.apply.f = f;
  return p;
}

mpc_parser_t *mpc_apply_to(mpc_parser_t *a, mpc_apply_to_t f, void *x) {
  mpc_parser_t *p = mpc_undefined();
  p->type = MPC_TYPE_APPLY_TO;
  p->data.apply_to.x = a;
  p->data.apply_to.f = f;
  p->data.apply_to.d = x;
  return p;
}

mpc_parser_t *mpc_check(mpc_parser_t *a, mpc_dtor_t da, mpc_check_t f, const char *e) {
  mpc_parser_t  *p = mpc_undefined();
  p->type = MPC_TYPE_CHECK;
  p->data.check.x = a;
  p->data.check.dx = da;
  p->data.check.f = f;
  p->data.check.e = malloc(strlen(e) + 1);
  strcpy(p->data.check.e, e);
  return p;
}

mpc_parser_t *mpc_check_with(mpc_parser_t *a, mpc_dtor_t da, mpc_check_with_t f, void *x, const char *e) {
  mpc_parser_t  *p = mpc_undefined();
  p->type = MPC_TYPE_CHECK_WITH;
  p->data.check_with.x = a;
  p->data.check_with.dx = da;
  p->data.check_with.f = f;
  p->data.check_with.d = x;
  p->data.check_with.e = malloc(strlen(e) + 1);
  strcpy(p->data.check_with.e, e);
  return p;
}

mpc_parser_t *mpc_checkf(mpc_parser_t *a, mpc_dtor_t da, mpc_check_t f, const char *fmt, ...) {
  va_list va;
  char *buffer;
  mpc_parser_t *p;

  ((void)((va) = (va_list)&(fmt)+((sizeof(fmt) + 3) & ~3)));
  buffer = malloc(2048);
  vsprintf(buffer, fmt, va);
  ((void)0);

  p = mpc_check(a, da, f, buffer);
  free(buffer);

  return p;
}

mpc_parser_t *mpc_check_withf(mpc_parser_t *a, mpc_dtor_t da, mpc_check_with_t f, void *x, const char *fmt, ...) {
  va_list va;
  char *buffer;
  mpc_parser_t *p;

  ((void)((va) = (va_list)&(fmt)+((sizeof(fmt) + 3) & ~3)));
  buffer = malloc(2048);
  vsprintf(buffer, fmt, va);
  ((void)0);

  p = mpc_check_with(a, da, f, x, buffer);
  free(buffer);

  return p;
}

mpc_parser_t *mpc_predictive(mpc_parser_t *a) {
  mpc_parser_t *p = mpc_undefined();
  p->type = MPC_TYPE_PREDICT;
  p->data.predict.x = a;
  return p;
}

mpc_parser_t *mpc_not_lift(mpc_parser_t *a, mpc_dtor_t da, mpc_ctor_t lf) {
  mpc_parser_t *p = mpc_undefined();
  p->type = MPC_TYPE_NOT;
  p->data.not.x = a;
  p->data.not.dx = da;
  p->data.not.lf = lf;
  return p;
}

mpc_parser_t *mpc_not(mpc_parser_t *a, mpc_dtor_t da) {
  return mpc_not_lift(a, da, mpcf_ctor_null);
}

mpc_parser_t *mpc_maybe_lift(mpc_parser_t *a, mpc_ctor_t lf) {
  mpc_parser_t *p = mpc_undefined();
  p->type = MPC_TYPE_MAYBE;
  p->data.not.x = a;
  p->data.not.lf = lf;
  return p;
}

mpc_parser_t *mpc_maybe(mpc_parser_t *a) {
  return mpc_maybe_lift(a, mpcf_ctor_null);
}

mpc_parser_t *mpc_many(mpc_fold_t f, mpc_parser_t *a) {
  mpc_parser_t *p = mpc_undefined();
  p->type = MPC_TYPE_MANY;
  p->data.repeat.x = a;
  p->data.repeat.f = f;
  return p;
}

mpc_parser_t *mpc_many1(mpc_fold_t f, mpc_parser_t *a) {
  mpc_parser_t *p = mpc_undefined();
  p->type = MPC_TYPE_MANY1;
  p->data.repeat.x = a;
  p->data.repeat.f = f;
  return p;
}

mpc_parser_t *mpc_count(int n, mpc_fold_t f, mpc_parser_t *a, mpc_dtor_t da) {
  mpc_parser_t *p = mpc_undefined();
  p->type = MPC_TYPE_COUNT;
  p->data.repeat.n = n;
  p->data.repeat.f = f;
  p->data.repeat.x = a;
  p->data.repeat.dx = da;
  return p;
}

mpc_parser_t *mpc_or(int n, ...) {

  int i;
  va_list va;

  mpc_parser_t *p = mpc_undefined();

  p->type = MPC_TYPE_OR;
  p->data.or.n = n;
  p->data.or.xs = malloc(sizeof(mpc_parser_t*) * n);

  ((void)((va) = (va_list)&(n)+((sizeof(n) + 3) & ~3)));
  for (i = 0; i < n; i++) {
    p->data.or.xs[i] = (*(mpc_parser_t*  *)(((va)+=((sizeof(mpc_parser_t*) + 3) & ~3))-(((sizeof(mpc_parser_t*) + 3) & ~3))));
  }
  ((void)0);

  return p;
}

mpc_parser_t *mpc_and(int n, mpc_fold_t f, ...) {

  int i;
  va_list va;

  mpc_parser_t *p = mpc_undefined();

  p->type = MPC_TYPE_AND;
  p->data.and.n = n;
  p->data.and.f = f;
  p->data.and.xs = malloc(sizeof(mpc_parser_t*) * n);
  p->data.and.dxs = malloc(sizeof(mpc_dtor_t) * (n-1));

  ((void)((va) = (va_list)&(f)+((sizeof(f) + 3) & ~3)));
  for (i = 0; i < n; i++) {
    p->data.and.xs[i] = (*(mpc_parser_t*  *)(((va)+=((sizeof(mpc_parser_t*) + 3) & ~3))-(((sizeof(mpc_parser_t*) + 3) & ~3))));
  }
  for (i = 0; i < (n-1); i++) {
    p->data.and.dxs[i] = (*(mpc_dtor_t  *)(((va)+=((sizeof(mpc_dtor_t) + 3) & ~3))-(((sizeof(mpc_dtor_t) + 3) & ~3))));
  }
  ((void)0);

  return p;
}

/*
** Common Parsers
*/

mpc_parser_t *mpc_soi(void) {
  mpc_parser_t *p = mpc_undefined();
  p->type = MPC_TYPE_SOI;
  return mpc_expect(p, "start of input");
}

mpc_parser_t *mpc_eoi(void) {
  mpc_parser_t *p = mpc_undefined();
  p->type = MPC_TYPE_EOI;
  return mpc_expect(p, "end of input");
}

static int mpc_boundary_anchor(char prev, char next) {
  const char* word = "abcdefghijklmnopqrstuvwxyz"
                     "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                     "0123456789_";
  if ( strchr(word, next) &&  prev == '\0') { return 1; }
  if ( strchr(word, prev) &&  next == '\0') { return 1; }
  if ( strchr(word, next) && !strchr(word, prev)) { return 1; }
  if (!strchr(word, next) &&  strchr(word, prev)) { return 1; }
  return 0;
}

static int mpc_boundary_newline_anchor(char prev, char next) {
  (void)next;
  return prev == '\n';
}

mpc_parser_t *mpc_boundary(void) { return mpc_expect(mpc_anchor(mpc_boundary_anchor), "word boundary"); }
mpc_parser_t *mpc_boundary_newline(void) { return mpc_expect(mpc_anchor(mpc_boundary_newline_anchor), "start of newline"); }

mpc_parser_t *mpc_whitespace(void) { return mpc_expect(mpc_oneof(" \f\n\r\t\v"), "whitespace"); }
mpc_parser_t *mpc_whitespaces(void) { return mpc_expect(mpc_many(mpcf_strfold, mpc_whitespace()), "spaces"); }
mpc_parser_t *mpc_blank(void) { return mpc_expect(mpc_apply(mpc_whitespaces(), mpcf_free), "whitespace"); }

mpc_parser_t *mpc_newline(void) { return mpc_expect(mpc_char('\n'), "newline"); }
mpc_parser_t *mpc_tab(void) { return mpc_expect(mpc_char('\t'), "tab"); }
mpc_parser_t *mpc_escape(void) { return mpc_and(2, mpcf_strfold, mpc_char('\\'), mpc_any(), free); }

mpc_parser_t *mpc_digit(void) { return mpc_expect(mpc_oneof("0123456789"), "digit"); }
mpc_parser_t *mpc_hexdigit(void) { return mpc_expect(mpc_oneof("0123456789ABCDEFabcdef"), "hex digit"); }
mpc_parser_t *mpc_octdigit(void) { return mpc_expect(mpc_oneof("01234567"), "oct digit"); }
mpc_parser_t *mpc_digits(void) { return mpc_expect(mpc_many1(mpcf_strfold, mpc_digit()), "digits"); }
mpc_parser_t *mpc_hexdigits(void) { return mpc_expect(mpc_many1(mpcf_strfold, mpc_hexdigit()), "hex digits"); }
mpc_parser_t *mpc_octdigits(void) { return mpc_expect(mpc_many1(mpcf_strfold, mpc_octdigit()), "oct digits"); }

mpc_parser_t *mpc_lower(void) { return mpc_expect(mpc_oneof("abcdefghijklmnopqrstuvwxyz"), "lowercase letter"); }
mpc_parser_t *mpc_upper(void) { return mpc_expect(mpc_oneof("ABCDEFGHIJKLMNOPQRSTUVWXYZ"), "uppercase letter"); }
mpc_parser_t *mpc_alpha(void) { return mpc_expect(mpc_oneof("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"), "letter"); }
mpc_parser_t *mpc_underscore(void) { return mpc_expect(mpc_char('_'), "underscore"); }
mpc_parser_t *mpc_alphanum(void) { return mpc_expect(mpc_or(3, mpc_alpha(), mpc_digit(), mpc_underscore()), "alphanumeric"); }

mpc_parser_t *mpc_int(void) { return mpc_expect(mpc_apply(mpc_digits(), mpcf_int), "integer"); }
mpc_parser_t *mpc_hex(void) { return mpc_expect(mpc_apply(mpc_hexdigits(), mpcf_hex), "hexadecimal"); }
mpc_parser_t *mpc_oct(void) { return mpc_expect(mpc_apply(mpc_octdigits(), mpcf_oct), "octadecimal"); }
mpc_parser_t *mpc_number(void) { return mpc_expect(mpc_or(3, mpc_int(), mpc_hex(), mpc_oct()), "number"); }

mpc_parser_t *mpc_real(void) {

  /* [+-]?\d+(\.\d+)?([eE][+-]?[0-9]+)? */

  mpc_parser_t *p0, *p1, *p2, *p30, *p31, *p32, *p3;

  p0 = mpc_maybe_lift(mpc_oneof("+-"), mpcf_ctor_str);
  p1 = mpc_digits();
  p2 = mpc_maybe_lift(mpc_and(2, mpcf_strfold, mpc_char('.'), mpc_digits(), free), mpcf_ctor_str);
  p30 = mpc_oneof("eE");
  p31 = mpc_maybe_lift(mpc_oneof("+-"), mpcf_ctor_str);
  p32 = mpc_digits();
  p3 = mpc_maybe_lift(mpc_and(3, mpcf_strfold, p30, p31, p32, free, free), mpcf_ctor_str);

  return mpc_expect(mpc_and(4, mpcf_strfold, p0, p1, p2, p3, free, free, free), "real");

}

mpc_parser_t *mpc_float(void) {
  return mpc_expect(mpc_apply(mpc_real(), mpcf_float), "float");
}

mpc_parser_t *mpc_char_lit(void) {
  return mpc_expect(mpc_between(mpc_or(2, mpc_escape(), mpc_any()), free, "'", "'"), "char");
}

mpc_parser_t *mpc_string_lit(void) {
  mpc_parser_t *strchar = mpc_or(2, mpc_escape(), mpc_noneof("\""));
  return mpc_expect(mpc_between(mpc_many(mpcf_strfold, strchar), free, "\"", "\""), "string");
}

mpc_parser_t *mpc_regex_lit(void) {
  mpc_parser_t *regexchar = mpc_or(2, mpc_escape(), mpc_noneof("/"));
  return mpc_expect(mpc_between(mpc_many(mpcf_strfold, regexchar), free, "/", "/"), "regex");
}

mpc_parser_t *mpc_ident(void) {
  mpc_parser_t *p0, *p1;
  p0 = mpc_or(2, mpc_alpha(), mpc_underscore());
  p1 = mpc_many(mpcf_strfold, mpc_alphanum());
  return mpc_and(2, mpcf_strfold, p0, p1, free);
}

/*
** Useful Parsers
*/

mpc_parser_t *mpc_startwith(mpc_parser_t *a) { return mpc_and(2, mpcf_snd, mpc_soi(), a, mpcf_dtor_null); }
mpc_parser_t *mpc_endwith(mpc_parser_t *a, mpc_dtor_t da) { return mpc_and(2, mpcf_fst, a, mpc_eoi(), da); }
mpc_parser_t *mpc_whole(mpc_parser_t *a, mpc_dtor_t da) { return mpc_and(3, mpcf_snd, mpc_soi(), a, mpc_eoi(), mpcf_dtor_null, da); }

mpc_parser_t *mpc_stripl(mpc_parser_t *a) { return mpc_and(2, mpcf_snd, mpc_blank(), a, mpcf_dtor_null); }
mpc_parser_t *mpc_stripr(mpc_parser_t *a) { return mpc_and(2, mpcf_fst, a, mpc_blank(), mpcf_dtor_null); }
mpc_parser_t *mpc_strip(mpc_parser_t *a) { return mpc_and(3, mpcf_snd, mpc_blank(), a, mpc_blank(), mpcf_dtor_null, mpcf_dtor_null); }
mpc_parser_t *mpc_tok(mpc_parser_t *a) { return mpc_and(2, mpcf_fst, a, mpc_blank(), mpcf_dtor_null); }
mpc_parser_t *mpc_sym(const char *s) { return mpc_tok(mpc_string(s)); }

mpc_parser_t *mpc_total(mpc_parser_t *a, mpc_dtor_t da) { return mpc_whole(mpc_strip(a), da); }

mpc_parser_t *mpc_between(mpc_parser_t *a, mpc_dtor_t ad, const char *o, const char *c) {
  return mpc_and(3, mpcf_snd_free,
    mpc_string(o), a, mpc_string(c),
    free, ad);
}

mpc_parser_t *mpc_parens(mpc_parser_t *a, mpc_dtor_t ad)   { return mpc_between(a, ad, "(", ")"); }
mpc_parser_t *mpc_braces(mpc_parser_t *a, mpc_dtor_t ad)   { return mpc_between(a, ad, "<", ">"); }
mpc_parser_t *mpc_brackets(mpc_parser_t *a, mpc_dtor_t ad) { return mpc_between(a, ad, "{", "}"); }
mpc_parser_t *mpc_squares(mpc_parser_t *a, mpc_dtor_t ad)  { return mpc_between(a, ad, "[", "]"); }

mpc_parser_t *mpc_tok_between(mpc_parser_t *a, mpc_dtor_t ad, const char *o, const char *c) {
  return mpc_and(3, mpcf_snd_free,
    mpc_sym(o), mpc_tok(a), mpc_sym(c),
    free, ad);
}

mpc_parser_t *mpc_tok_parens(mpc_parser_t *a, mpc_dtor_t ad)   { return mpc_tok_between(a, ad, "(", ")"); }
mpc_parser_t *mpc_tok_braces(mpc_parser_t *a, mpc_dtor_t ad)   { return mpc_tok_between(a, ad, "<", ">"); }
mpc_parser_t *mpc_tok_brackets(mpc_parser_t *a, mpc_dtor_t ad) { return mpc_tok_between(a, ad, "{", "}"); }
mpc_parser_t *mpc_tok_squares(mpc_parser_t *a, mpc_dtor_t ad)  { return mpc_tok_between(a, ad, "[", "]"); }

/*
** Regular Expression Parsers
*/

/*
** So here is a cute bootstrapping.
**
** I'm using the previously defined
** mpc constructs and functions to
** parse the user regex string and
** construct a parser from it.
**
** As it turns out lots of the standard
** mpc functions look a lot like `fold`
** functions and so can be used indirectly
** by many of the parsing functions to build
** a parser directly - as we are parsing.
**
** This is certainly something that
** would be less elegant/interesting
** in a two-phase parser which first
** builds an AST and then traverses it
** to generate the object.
**
** This whole thing acts as a great
** case study for how trivial it can be
** to write a great parser in a few
** lines of code using mpc.
*/

/*
**
**  ### Regular Expression Grammar
**
**      <regex> : <term> | (<term> "|" <regex>)
**
**      <term> : <factor>*
**
**      <factor> : <base>
**               | <base> "*"
**               | <base> "+"
**               | <base> "?"
**               | <base> "{" <digits> "}"
**
**      <base> : <char>
**             | "\" <char>
**             | "(" <regex> ")"
**             | "[" <range> "]"
*/

static mpc_val_t *mpcf_re_or(int n, mpc_val_t **xs) {
  (void) n;
  if (xs[1] == ((void *)0)) { return xs[0]; }
  else { return mpc_or(2, xs[0], xs[1]); }
}

static mpc_val_t *mpcf_re_and(int n, mpc_val_t **xs) {
  int i;
  mpc_parser_t *p = mpc_lift(mpcf_ctor_str);
  for (i = 0; i < n; i++) {
    p = mpc_and(2, mpcf_strfold, p, xs[i], free);
  }
  return p;
}

static mpc_val_t *mpcf_re_repeat(int n, mpc_val_t **xs) {
  int num;
  (void) n;
  if (xs[1] == ((void *)0)) { return xs[0]; }
  switch(((char*)xs[1])[0])
  {
    case '*': { free(xs[1]); return mpc_many(mpcf_strfold, xs[0]); }; break;
    case '+': { free(xs[1]); return mpc_many1(mpcf_strfold, xs[0]); }; break;
    case '?': { free(xs[1]); return mpc_maybe_lift(xs[0], mpcf_ctor_str); }; break;
    default:
      num = *(int*)xs[1];
      free(xs[1]);
  }

  return mpc_count(num, mpcf_strfold, xs[0], free);
}

static mpc_parser_t *mpc_re_escape_char(char c) {
  switch (c) {
    case 'a': return mpc_char('\a');
    case 'f': return mpc_char('\f');
    case 'n': return mpc_char('\n');
    case 'r': return mpc_char('\r');
    case 't': return mpc_char('\t');
    case 'v': return mpc_char('\v');
    case 'b': return mpc_and(2, mpcf_snd, mpc_boundary(), mpc_lift(mpcf_ctor_str), free);
    case 'B': return mpc_not_lift(mpc_boundary(), free, mpcf_ctor_str);
    case 'A': return mpc_and(2, mpcf_snd, mpc_soi(), mpc_lift(mpcf_ctor_str), free);
    case 'Z': return mpc_and(2, mpcf_snd, mpc_eoi(), mpc_lift(mpcf_ctor_str), free);
    case 'd': return mpc_digit();
    case 'D': return mpc_not_lift(mpc_digit(), free, mpcf_ctor_str);
    case 's': return mpc_whitespace();
    case 'S': return mpc_not_lift(mpc_whitespace(), free, mpcf_ctor_str);
    case 'w': return mpc_alphanum();
    case 'W': return mpc_not_lift(mpc_alphanum(), free, mpcf_ctor_str);
    default: return ((void *)0);
  }
}

static mpc_val_t *mpcf_re_escape(mpc_val_t *x, void* data) {

  int mode = *((int*)data);
  char *s = x;
  mpc_parser_t *p;

  /* Any Character */
  if (s[0] == '.') {
    free(s);
    if (mode & MPC_RE_DOTALL) {
      return mpc_any();
    } else {
      return mpc_expect(mpc_noneof("\n"), "any character except a newline");
    }
  }

  /* Start of Input */
  if (s[0] == '^') {
    free(s);
    if (mode & MPC_RE_MULTILINE) {
      return mpc_and(2, mpcf_snd, mpc_or(2, mpc_soi(), mpc_boundary_newline()), mpc_lift(mpcf_ctor_str), free);
    } else {
      return mpc_and(2, mpcf_snd, mpc_soi(), mpc_lift(mpcf_ctor_str), free);
    }
  }

  /* End of Input */
  if (s[0] == '$') {
    free(s);
    if (mode & MPC_RE_MULTILINE) {
      return mpc_or(2,
        mpc_newline(),
        mpc_and(2, mpcf_snd, mpc_eoi(), mpc_lift(mpcf_ctor_str), free));
    } else {
      return mpc_or(2,
        mpc_and(2, mpcf_fst, mpc_newline(), mpc_eoi(), free),
        mpc_and(2, mpcf_snd, mpc_eoi(), mpc_lift(mpcf_ctor_str), free));
    }
  }

  /* Regex Escape */
  if (s[0] == '\\') {
    p = mpc_re_escape_char(s[1]);
    p = (p == ((void *)0)) ? mpc_char(s[1]) : p;
    free(s);
    return p;
  }

  /* Regex Standard */
  p = mpc_char(s[0]);
  free(s);
  return p;
}

static const char *mpc_re_range_escape_char(char c) {
  switch (c) {
    case '-': return "-";
    case 'a': return "\a";
    case 'f': return "\f";
    case 'n': return "\n";
    case 'r': return "\r";
    case 't': return "\t";
    case 'v': return "\v";
    case 'b': return "\b";
    case 'd': return "0123456789";
    case 's': return " \f\n\r\t\v";
    case 'w': return "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_";
    default: return ((void *)0);
  }
}

static mpc_val_t *mpcf_re_range(mpc_val_t *x) {

  mpc_parser_t *out;
  size_t i, j;
  size_t start, end;
  const char *tmp = ((void *)0);
  const char *s = x;
  int comp = s[0] == '^' ? 1 : 0;
  char *range = calloc(1,1);

  if (s[0] == '\0') { free(range); free(x); return mpc_fail("Invalid Regex Range Expression"); }
  if (s[0] == '^' &&
      s[1] == '\0') { free(range); free(x); return mpc_fail("Invalid Regex Range Expression"); }

  for (i = comp; i < strlen(s); i++){

    /* Regex Range Escape */
    if (s[i] == '\\') {
      tmp = mpc_re_range_escape_char(s[i+1]);
      if (tmp != ((void *)0)) {
        range = realloc(range, strlen(range) + strlen(tmp) + 1);
        strcat(range, tmp);
      } else {
        range = realloc(range, strlen(range) + 1 + 1);
        range[strlen(range) + 1] = '\0';
        range[strlen(range) + 0] = s[i+1];
      }
      i++;
    }

    /* Regex Range...Range */
    else if (s[i] == '-') {
      if (s[i+1] == '\0' || i == 0) {
          range = realloc(range, strlen(range) + strlen("-") + 1);
          strcat(range, "-");
      } else {
        start = s[i-1]+1;
        end = s[i+1]-1;
        for (j = start; j <= end; j++) {
          range = realloc(range, strlen(range) + 1 + 1 + 1);
          range[strlen(range) + 1] = '\0';
          range[strlen(range) + 0] = (char)j;
        }
      }
    }

    /* Regex Range Normal */
    else {
      range = realloc(range, strlen(range) + 1 + 1);
      range[strlen(range) + 1] = '\0';
      range[strlen(range) + 0] = s[i];
    }

  }

  out = comp == 1 ? mpc_noneof(range) : mpc_oneof(range);

  free(x);
  free(range);

  return out;
}

mpc_parser_t *mpc_re(const char *re) {
  return mpc_re_mode(re, MPC_RE_DEFAULT);
}

mpc_parser_t *mpc_re_mode(const char *re, int mode) {

  char *err_msg;
  mpc_parser_t *err_out;
  mpc_result_t r;
  mpc_parser_t *Regex, *Term, *Factor, *Base, *Range, *RegexEnclose;

  Regex  = mpc_new("regex");
  Term   = mpc_new("term");
  Factor = mpc_new("factor");
  Base   = mpc_new("base");
  Range  = mpc_new("range");

  mpc_define(Regex, mpc_and(2, mpcf_re_or,
    Term,
    mpc_maybe(mpc_and(2, mpcf_snd_free, mpc_char('|'), Regex, free)),
    (mpc_dtor_t)mpc_delete
  ));

  mpc_define(Term, mpc_many(mpcf_re_and, Factor));

  mpc_define(Factor, mpc_and(2, mpcf_re_repeat,
    Base,
    mpc_or(5,
      mpc_char('*'), mpc_char('+'), mpc_char('?'),
      mpc_brackets(mpc_int(), free),
      mpc_pass()),
    (mpc_dtor_t)mpc_delete
  ));

  mpc_define(Base, mpc_or(4,
    mpc_parens(Regex, (mpc_dtor_t)mpc_delete),
    mpc_squares(Range, (mpc_dtor_t)mpc_delete),
    mpc_apply_to(mpc_escape(), mpcf_re_escape, &mode),
    mpc_apply_to(mpc_noneof(")|"), mpcf_re_escape, &mode)
  ));

  mpc_define(Range, mpc_apply(
    mpc_many(mpcf_strfold, mpc_or(2, mpc_escape(), mpc_noneof("]"))),
    mpcf_re_range
  ));

  RegexEnclose = mpc_whole(mpc_predictive(Regex), (mpc_dtor_t)mpc_delete);

  mpc_optimise(RegexEnclose);
  mpc_optimise(Regex);
  mpc_optimise(Term);
  mpc_optimise(Factor);
  mpc_optimise(Base);
  mpc_optimise(Range);

  if(!mpc_parse("<mpc_re_compiler>", re, RegexEnclose, &r)) {
    err_msg = mpc_err_string(r.error);
    err_out = mpc_failf("Invalid Regex: %s", err_msg);
    mpc_err_delete(r.error);
    free(err_msg);
    r.output = err_out;
  }

  mpc_cleanup(6, RegexEnclose, Regex, Term, Factor, Base, Range);

  mpc_optimise(r.output);

  return r.output;

}

/*
** Common Fold Functions
*/

void mpcf_dtor_null(mpc_val_t *x) { (void) x; return; }

mpc_val_t *mpcf_ctor_null(void) { return ((void *)0); }
mpc_val_t *mpcf_ctor_str(void) { return calloc(1, 1); }
mpc_val_t *mpcf_free(mpc_val_t *x) { free(x); return ((void *)0); }

mpc_val_t *mpcf_int(mpc_val_t *x) {
  int *y = malloc(sizeof(int));
  *y = strtol(x, ((void *)0), 10);
  free(x);
  return y;
}

mpc_val_t *mpcf_hex(mpc_val_t *x) {
  int *y = malloc(sizeof(int));
  *y = strtol(x, ((void *)0), 16);
  free(x);
  return y;
}

mpc_val_t *mpcf_oct(mpc_val_t *x) {
  int *y = malloc(sizeof(int));
  *y = strtol(x, ((void *)0), 8);
  free(x);
  return y;
}

mpc_val_t *mpcf_float(mpc_val_t *x) {
  float *y = malloc(sizeof(float));
  *y = strtod(x, ((void *)0));
  free(x);
  return y;
}

mpc_val_t *mpcf_strtriml(mpc_val_t *x) {
  char *s = x;
  while ((__locale_mbsize>1?_isctype((unsigned char)*s,8):_pctype[(unsigned char)*s]&8)) {
    memmove(s, s+1, strlen(s));
  }
  return s;
}

mpc_val_t *mpcf_strtrimr(mpc_val_t *x) {
  char *s = x;
  size_t l = strlen(s);
  while (l > 0 && (__locale_mbsize>1?_isctype((unsigned char)s[l-1],8):_pctype[(unsigned char)s[l-1]]&8)) {
    s[l-1] = '\0'; l--;
  }
  return s;
}

mpc_val_t *mpcf_strtrim(mpc_val_t *x) {
  return mpcf_strtriml(mpcf_strtrimr(x));
}

static const char mpc_escape_input_c[]  = {
  '\a', '\b', '\f', '\n', '\r',
  '\t', '\v', '\\', '\'', '\"', '\0'};

static const char *mpc_escape_output_c[] = {
  "\\a", "\\b", "\\f", "\\n", "\\r", "\\t",
  "\\v", "\\\\", "\\'", "\\\"", "\\0", ((void *)0)};

static const char mpc_escape_input_raw_re[] = { '/' };
static const char *mpc_escape_output_raw_re[] = { "\\/", ((void *)0) };

static const char mpc_escape_input_raw_cstr[] = { '"' };
static const char *mpc_escape_output_raw_cstr[] = { "\\\"", ((void *)0) };

static const char mpc_escape_input_raw_cchar[] = { '\'' };
static const char *mpc_escape_output_raw_cchar[] = { "\\'", ((void *)0) };

static mpc_val_t *mpcf_escape_new(mpc_val_t *x, const char *input, const char **output) {

  int i;
  int found;
  char buff[2];
  char *s = x;
  char *y = calloc(1, 1);

  while (*s) {

    i = 0;
    found = 0;

    while (output[i]) {
      if (*s == input[i]) {
        y = realloc(y, strlen(y) + strlen(output[i]) + 1);
        strcat(y, output[i]);
        found = 1;
        break;
      }
      i++;
    }

    if (!found) {
      y = realloc(y, strlen(y) + 2);
      buff[0] = *s; buff[1] = '\0';
      strcat(y, buff);
    }

    s++;
  }


  return y;
}

static mpc_val_t *mpcf_unescape_new(mpc_val_t *x, const char *input, const char **output) {

  int i;
  int found = 0;
  char buff[2];
  char *s = x;
  char *y = calloc(1, 1);

  while (*s) {

    i = 0;
    found = 0;

    while (output[i]) {
      if ((*(s+0)) == output[i][0] &&
          (*(s+1)) == output[i][1]) {
        y = realloc(y, strlen(y) + 1 + 1);
        buff[0] = input[i]; buff[1] = '\0';
        strcat(y, buff);
        found = 1;
        s++;
        break;
      }
      i++;
    }

    if (!found) {
      y = realloc(y, strlen(y) + 1 + 1);
      buff[0] = *s; buff[1] = '\0';
      strcat(y, buff);
    }

    if (*s == '\0') { break; }
    else { s++; }
  }

  return y;

}

mpc_val_t *mpcf_escape(mpc_val_t *x) {
  mpc_val_t *y = mpcf_escape_new(x, mpc_escape_input_c, mpc_escape_output_c);
  free(x);
  return y;
}

mpc_val_t *mpcf_unescape(mpc_val_t *x) {
  mpc_val_t *y = mpcf_unescape_new(x, mpc_escape_input_c, mpc_escape_output_c);
  free(x);
  return y;
}

mpc_val_t *mpcf_escape_regex(mpc_val_t *x) {
  mpc_val_t *y = mpcf_escape_new(x, mpc_escape_input_raw_re, mpc_escape_output_raw_re);
  free(x);
  return y;
}

mpc_val_t *mpcf_unescape_regex(mpc_val_t *x) {
  mpc_val_t *y = mpcf_unescape_new(x, mpc_escape_input_raw_re, mpc_escape_output_raw_re);
  free(x);
  return y;
}

mpc_val_t *mpcf_escape_string_raw(mpc_val_t *x) {
  mpc_val_t *y = mpcf_escape_new(x, mpc_escape_input_raw_cstr, mpc_escape_output_raw_cstr);
  free(x);
  return y;
}

mpc_val_t *mpcf_unescape_string_raw(mpc_val_t *x) {
  mpc_val_t *y = mpcf_unescape_new(x, mpc_escape_input_raw_cstr, mpc_escape_output_raw_cstr);
  free(x);
  return y;
}

mpc_val_t *mpcf_escape_char_raw(mpc_val_t *x) {
  mpc_val_t *y = mpcf_escape_new(x, mpc_escape_input_raw_cchar, mpc_escape_output_raw_cchar);
  free(x);
  return y;
}

mpc_val_t *mpcf_unescape_char_raw(mpc_val_t *x) {
  mpc_val_t *y = mpcf_unescape_new(x, mpc_escape_input_raw_cchar, mpc_escape_output_raw_cchar);
  free(x);
  return y;
}

mpc_val_t *mpcf_null(int n, mpc_val_t** xs) { (void) n; (void) xs; return ((void *)0); }
mpc_val_t *mpcf_fst(int n, mpc_val_t **xs) { (void) n; return xs[0]; }
mpc_val_t *mpcf_snd(int n, mpc_val_t **xs) { (void) n; return xs[1]; }
mpc_val_t *mpcf_trd(int n, mpc_val_t **xs) { (void) n; return xs[2]; }

static mpc_val_t *mpcf_nth_free(int n, mpc_val_t **xs, int x) {
  int i;
  for (i = 0; i < n; i++) {
    if (i != x) { free(xs[i]); }
  }
  return xs[x];
}

mpc_val_t *mpcf_fst_free(int n, mpc_val_t **xs) { return mpcf_nth_free(n, xs, 0); }
mpc_val_t *mpcf_snd_free(int n, mpc_val_t **xs) { return mpcf_nth_free(n, xs, 1); }
mpc_val_t *mpcf_trd_free(int n, mpc_val_t **xs) { return mpcf_nth_free(n, xs, 2); }

mpc_val_t *mpcf_freefold(int n, mpc_val_t **xs) {
  int i;
  for (i = 0; i < n; i++) {
    free(xs[i]);
  }
  return ((void *)0);
}

mpc_val_t *mpcf_strfold(int n, mpc_val_t **xs) {
  int i;
  size_t l = 0;

  if (n == 0) { return calloc(1, 1); }

  for (i = 0; i < n; i++) { l += strlen(xs[i]); }

  xs[0] = realloc(xs[0], l + 1);

  for (i = 1; i < n; i++) {
    strcat(xs[0], xs[i]); free(xs[i]);
  }

  return xs[0];
}

mpc_val_t *mpcf_maths(int n, mpc_val_t **xs) {
  int **vs = (int**)xs;
  (void) n;

  switch(((char*)xs[1])[0])
  {
    case '*': { *vs[0] *= *vs[2]; }; break;
    case '/': { *vs[0] /= *vs[2]; }; break;
    case '%': { *vs[0] %= *vs[2]; }; break;
    case '+': { *vs[0] += *vs[2]; }; break;
    case '-': { *vs[0] -= *vs[2]; }; break;
    default: break;
  }

  free(xs[1]); free(xs[2]);

  return xs[0];
}

/*
** Printing
*/

static void mpc_print_unretained(mpc_parser_t *p, int force) {

  /* TODO: Print Everything Escaped */

  int i;
  char *s, *e;
  char buff[2];

  if (p->retained && !force) {;
    if (p->name) { printf("<%s>", p->name); }
    else { printf("<anon>"); }
    return;
  }

  if (p->type == MPC_TYPE_UNDEFINED) { printf("<?>"); }
  if (p->type == MPC_TYPE_PASS)   { printf("<:>"); }
  if (p->type == MPC_TYPE_FAIL)   { printf("<!>"); }
  if (p->type == MPC_TYPE_LIFT)   { printf("<#>"); }
  if (p->type == MPC_TYPE_STATE)  { printf("<S>"); }
  if (p->type == MPC_TYPE_ANCHOR) { printf("<@>"); }
  if (p->type == MPC_TYPE_EXPECT) {
    printf("%s", p->data.expect.m);
    /*mpc_print_unretained(p->data.expect.x, 0);*/
  }

  if (p->type == MPC_TYPE_ANY) { printf("<.>"); }
  if (p->type == MPC_TYPE_SATISFY) { printf("<f>"); }

  if (p->type == MPC_TYPE_SINGLE) {
    buff[0] = p->data.single.x; buff[1] = '\0';
    s = mpcf_escape_new(
      buff,
      mpc_escape_input_c,
      mpc_escape_output_c);
    printf("'%s'", s);
    free(s);
  }

  if (p->type == MPC_TYPE_RANGE) {
    buff[0] = p->data.range.x; buff[1] = '\0';
    s = mpcf_escape_new(
      buff,
      mpc_escape_input_c,
      mpc_escape_output_c);
    buff[0] = p->data.range.y; buff[1] = '\0';
    e = mpcf_escape_new(
      buff,
      mpc_escape_input_c,
      mpc_escape_output_c);
    printf("[%s-%s]", s, e);
    free(s);
    free(e);
  }

  if (p->type == MPC_TYPE_ONEOF) {
    s = mpcf_escape_new(
      p->data.string.x,
      mpc_escape_input_c,
      mpc_escape_output_c);
    printf("[%s]", s);
    free(s);
  }

  if (p->type == MPC_TYPE_NONEOF) {
    s = mpcf_escape_new(
      p->data.string.x,
      mpc_escape_input_c,
      mpc_escape_output_c);
    printf("[^%s]", s);
    free(s);
  }

  if (p->type == MPC_TYPE_STRING) {
    s = mpcf_escape_new(
      p->data.string.x,
      mpc_escape_input_c,
      mpc_escape_output_c);
    printf("\"%s\"", s);
    free(s);
  }

  if (p->type == MPC_TYPE_APPLY)    { mpc_print_unretained(p->data.apply.x, 0); }
  if (p->type == MPC_TYPE_APPLY_TO) { mpc_print_unretained(p->data.apply_to.x, 0); }
  if (p->type == MPC_TYPE_PREDICT)  { mpc_print_unretained(p->data.predict.x, 0); }

  if (p->type == MPC_TYPE_NOT)   { mpc_print_unretained(p->data.not.x, 0); printf("!"); }
  if (p->type == MPC_TYPE_MAYBE) { mpc_print_unretained(p->data.not.x, 0); printf("?"); }

  if (p->type == MPC_TYPE_MANY)  { mpc_print_unretained(p->data.repeat.x, 0); printf("*"); }
  if (p->type == MPC_TYPE_MANY1) { mpc_print_unretained(p->data.repeat.x, 0); printf("+"); }
  if (p->type == MPC_TYPE_COUNT) { mpc_print_unretained(p->data.repeat.x, 0); printf("{%i}", p->data.repeat.n); }

  if (p->type == MPC_TYPE_OR) {
    printf("(");
    for(i = 0; i < p->data.or.n-1; i++) {
      mpc_print_unretained(p->data.or.xs[i], 0);
      printf(" | ");
    }
    mpc_print_unretained(p->data.or.xs[p->data.or.n-1], 0);
    printf(")");
  }

  if (p->type == MPC_TYPE_AND) {
    printf("(");
    for(i = 0; i < p->data.and.n-1; i++) {
      mpc_print_unretained(p->data.and.xs[i], 0);
      printf(" ");
    }
    mpc_print_unretained(p->data.and.xs[p->data.and.n-1], 0);
    printf(")");
  }

  if (p->type == MPC_TYPE_CHECK) {
    mpc_print_unretained(p->data.check.x, 0);
    printf("->?");
  }
  if (p->type == MPC_TYPE_CHECK_WITH) {
    mpc_print_unretained(p->data.check_with.x, 0);
    printf("->?");
  }

}

void mpc_print(mpc_parser_t *p) {
  mpc_print_unretained(p, 1);
  printf("\n");
}

/*
** Testing
*/

/*
** These functions are slightly unwieldy and
** also the whole of the testing suite for mpc
** mpc is pretty shaky.
**
** It could do with a lot more tests and more
** precision. Currently I am only really testing
** changes off of the examples.
**
*/

int mpc_test_fail(mpc_parser_t *p, const char *s, const void *d,
  int(*tester)(const void*, const void*),
  mpc_dtor_t destructor,
  void(*printer)(const void*)) {
  mpc_result_t r;
  (void) printer;
  if (mpc_parse("<test>", s, p, &r)) {

    if (tester(r.output, d)) {
      destructor(r.output);
      return 0;
    } else {
      destructor(r.output);
      return 1;
    }

  } else {
    mpc_err_delete(r.error);
    return 1;
  }

}

int mpc_test_pass(mpc_parser_t *p, const char *s, const void *d,
  int(*tester)(const void*, const void*),
  mpc_dtor_t destructor,
  void(*printer)(const void*)) {

  mpc_result_t r;
  if (mpc_parse("<test>", s, p, &r)) {

    if (tester(r.output, d)) {
      destructor(r.output);
      return 1;
    } else {
      printf("Got "); printer(r.output); printf("\n");
      printf("Expected "); printer(d); printf("\n");
      destructor(r.output);
      return 0;
    }

  } else {
    mpc_err_print(r.error);
    mpc_err_delete(r.error);
    return 0;

  }

}


/*
** AST
*/

void mpc_ast_delete(mpc_ast_t *a) {

  int i;

  if (a == ((void *)0)) { return; }

  for (i = 0; i < a->children_num; i++) {
    mpc_ast_delete(a->children[i]);
  }

  free(a->children);
  free(a->tag);
  free(a->contents);
  free(a);

}

static void mpc_ast_delete_no_children(mpc_ast_t *a) {
  free(a->children);
  free(a->tag);
  free(a->contents);
  free(a);
}

mpc_ast_t *mpc_ast_new(const char *tag, const char *contents) {

  mpc_ast_t *a = malloc(sizeof(mpc_ast_t));

  a->tag = malloc(strlen(tag) + 1);
  strcpy(a->tag, tag);

  a->contents = malloc(strlen(contents) + 1);
  strcpy(a->contents, contents);

  a->state = mpc_state_new();

  a->children_num = 0;
  a->children = ((void *)0);
  return a;

}

mpc_ast_t *mpc_ast_build(int n, const char *tag, ...) {

  mpc_ast_t *a = mpc_ast_new(tag, "");

  int i;
  va_list va;
  ((void)((va) = (va_list)&(tag)+((sizeof(tag) + 3) & ~3)));

  for (i = 0; i < n; i++) {
    mpc_ast_add_child(a, (*(mpc_ast_t*  *)(((va)+=((sizeof(mpc_ast_t*) + 3) & ~3))-(((sizeof(mpc_ast_t*) + 3) & ~3)))));
  }

  ((void)0);

  return a;

}

mpc_ast_t *mpc_ast_add_root(mpc_ast_t *a) {

  mpc_ast_t *r;

  if (a == ((void *)0)) { return a; }
  if (a->children_num == 0) { return a; }
  if (a->children_num == 1) { return a; }

  r = mpc_ast_new(">", "");
  mpc_ast_add_child(r, a);
  return r;
}

int mpc_ast_eq(mpc_ast_t *a, mpc_ast_t *b) {

  int i;

  if (strcmp(a->tag, b->tag) != 0) { return 0; }
  if (strcmp(a->contents, b->contents) != 0) { return 0; }
  if (a->children_num != b->children_num) { return 0; }

  for (i = 0; i < a->children_num; i++) {
    if (!mpc_ast_eq(a->children[i], b->children[i])) { return 0; }
  }

  return 1;
}

mpc_ast_t *mpc_ast_add_child(mpc_ast_t *r, mpc_ast_t *a) {
  r->children_num++;
  r->children = realloc(r->children, sizeof(mpc_ast_t*) * r->children_num);
  r->children[r->children_num-1] = a;
  return r;
}

mpc_ast_t *mpc_ast_add_tag(mpc_ast_t *a, const char *t) {
  if (a == ((void *)0)) { return a; }
  a->tag = realloc(a->tag, strlen(t) + 1 + strlen(a->tag) + 1);
  memmove(a->tag + strlen(t) + 1, a->tag, strlen(a->tag)+1);
  memmove(a->tag, t, strlen(t));
  memmove(a->tag + strlen(t), "|", 1);
  return a;
}

mpc_ast_t *mpc_ast_add_root_tag(mpc_ast_t *a, const char *t) {
  if (a == ((void *)0)) { return a; }
  a->tag = realloc(a->tag, (strlen(t)-1) + strlen(a->tag) + 1);
  memmove(a->tag + (strlen(t)-1), a->tag, strlen(a->tag)+1);
  memmove(a->tag, t, (strlen(t)-1));
  return a;
}

mpc_ast_t *mpc_ast_tag(mpc_ast_t *a, const char *t) {
  a->tag = realloc(a->tag, strlen(t) + 1);
  strcpy(a->tag, t);
  return a;
}

mpc_ast_t *mpc_ast_state(mpc_ast_t *a, mpc_state_t s) {
  if (a == ((void *)0)) { return a; }
  a->state = s;
  return a;
}

static void mpc_ast_print_depth(mpc_ast_t *a, int d, FILE *fp) {

  int i;

  if (a == ((void *)0)) {
    fprintf(fp, "NULL\n");
    return;
  }

  for (i = 0; i < d; i++) { fprintf(fp, "  "); }

  if (strlen(a->contents)) {
    fprintf(fp, "%s:%lu:%lu '%s'\n", a->tag,
      (long unsigned int)(a->state.row+1),
      (long unsigned int)(a->state.col+1),
      a->contents);
  } else {
    fprintf(fp, "%s \n", a->tag);
  }

  for (i = 0; i < a->children_num; i++) {
    mpc_ast_print_depth(a->children[i], d+1, fp);
  }

}

void mpc_ast_print(mpc_ast_t *a) {
  mpc_ast_print_depth(a, 0, (&_iob[1]));
}

void mpc_ast_print_to(mpc_ast_t *a, FILE *fp) {
  mpc_ast_print_depth(a, 0, fp);
}

int mpc_ast_get_index(mpc_ast_t *ast, const char *tag) {
  return mpc_ast_get_index_lb(ast, tag, 0);
}

int mpc_ast_get_index_lb(mpc_ast_t *ast, const char *tag, int lb) {
  int i;

  for(i=lb; i<ast->children_num; i++) {
    if(strcmp(ast->children[i]->tag, tag) == 0) {
      return i;
    }
  }

  return -1;
}

mpc_ast_t *mpc_ast_get_child(mpc_ast_t *ast, const char *tag) {
  return mpc_ast_get_child_lb(ast, tag, 0);
}

mpc_ast_t *mpc_ast_get_child_lb(mpc_ast_t *ast, const char *tag, int lb) {
  int i;

  for(i=lb; i<ast->children_num; i++) {
    if(strcmp(ast->children[i]->tag, tag) == 0) {
      return ast->children[i];
    }
  }

  return ((void *)0);
}

mpc_ast_trav_t *mpc_ast_traverse_start(mpc_ast_t *ast,
                                       mpc_ast_trav_order_t order)
{
  mpc_ast_trav_t *trav, *n_trav;
  mpc_ast_t *cnode = ast;

  /* Create the traversal structure */
  trav = malloc(sizeof(mpc_ast_trav_t));
  trav->curr_node = cnode;
  trav->parent = ((void *)0);
  trav->curr_child = 0;
  trav->order = order;

  /* Get start node */
  switch(order) {
    case mpc_ast_trav_order_pre:
      /* Nothing else is needed for pre order start */
      break;

    case mpc_ast_trav_order_post:
      while(cnode->children_num > 0) {
        cnode = cnode->children[0];

        n_trav = malloc(sizeof(mpc_ast_trav_t));
        n_trav->curr_node = cnode;
        n_trav->parent = trav;
        n_trav->curr_child = 0;
        n_trav->order = order;

        trav = n_trav;
      }

      break;

    default:
      /* Unreachable, but compiler complaints */
      break;
  }

  return trav;
}

mpc_ast_t *mpc_ast_traverse_next(mpc_ast_trav_t **trav) {
  mpc_ast_trav_t *n_trav, *to_free;
  mpc_ast_t *ret = ((void *)0);
  int cchild;

  /* The end of traversal was reached */
  if(*trav == ((void *)0)) return ((void *)0);

  switch((*trav)->order) {
    case mpc_ast_trav_order_pre:
      ret = (*trav)->curr_node;

      /* If there aren't any more children, go up */
      while(*trav != ((void *)0) &&
        (*trav)->curr_child >= (*trav)->curr_node->children_num)
      {
        to_free = *trav;
        *trav = (*trav)->parent;
        free(to_free);
      }

      /* If trav is NULL, the end was reached */
      if(*trav == ((void *)0)) {
        break;
      }

      /* Go to next child */
      n_trav = malloc(sizeof(mpc_ast_trav_t));

      cchild = (*trav)->curr_child;
      n_trav->curr_node = (*trav)->curr_node->children[cchild];
      n_trav->parent = *trav;
      n_trav->curr_child = 0;
      n_trav->order = (*trav)->order;

      (*trav)->curr_child++;
      *trav = n_trav;

      break;

    case mpc_ast_trav_order_post:
      ret = (*trav)->curr_node;

      /* Move up tree to the parent If the parent doesn't have any more nodes,
       * then this is the current node. If it does, move down to its left most
       * child. Also, free the previous traversal node */
      to_free = *trav;
      *trav = (*trav)->parent;
      free(to_free);

      if(*trav == ((void *)0))
        break;

      /* Next child */
      (*trav)->curr_child++;

      /* If there aren't any more children, this is the next node */
      if((*trav)->curr_child >= (*trav)->curr_node->children_num) {
        break;
      }

      /* If there are still more children, find the leftmost child from this
       * node */
      while((*trav)->curr_node->children_num > 0) {
        n_trav = malloc(sizeof(mpc_ast_trav_t));

        cchild = (*trav)->curr_child;
        n_trav->curr_node = (*trav)->curr_node->children[cchild];
        n_trav->parent = *trav;
        n_trav->curr_child = 0;
        n_trav->order = (*trav)->order;

        *trav = n_trav;
      }

    default:
      /* Unreachable, but compiler complaints */
      break;
  }

  return ret;
}

void mpc_ast_traverse_free(mpc_ast_trav_t **trav) {
  mpc_ast_trav_t *n_trav;

  /* Go through parents until all are free */
  while(*trav != ((void *)0)) {
      n_trav = (*trav)->parent;
      free(*trav);
      *trav = n_trav;
  }
}

mpc_val_t *mpcf_fold_ast(int n, mpc_val_t **xs) {

  int i, j;
  mpc_ast_t** as = (mpc_ast_t**)xs;
  mpc_ast_t *r;

  if (n == 0) { return ((void *)0); }
  if (n == 1) { return xs[0]; }
  if (n == 2 && xs[1] == ((void *)0)) { return xs[0]; }
  if (n == 2 && xs[0] == ((void *)0)) { return xs[1]; }

  r = mpc_ast_new(">", "");

  for (i = 0; i < n; i++) {

    if (as[i] == ((void *)0)) { continue; }

    if        (as[i] && as[i]->children_num == 0) {
      mpc_ast_add_child(r, as[i]);
    } else if (as[i] && as[i]->children_num == 1) {
      mpc_ast_add_child(r, mpc_ast_add_root_tag(as[i]->children[0], as[i]->tag));
      mpc_ast_delete_no_children(as[i]);
    } else if (as[i] && as[i]->children_num >= 2) {
      for (j = 0; j < as[i]->children_num; j++) {
        mpc_ast_add_child(r, as[i]->children[j]);
      }
      mpc_ast_delete_no_children(as[i]);
    }

  }

  if (r->children_num) {
    r->state = r->children[0]->state;
  }

  return r;
}

mpc_val_t *mpcf_str_ast(mpc_val_t *c) {
  mpc_ast_t *a = mpc_ast_new("", c);
  free(c);
  return a;
}

mpc_val_t *mpcf_state_ast(int n, mpc_val_t **xs) {
  mpc_state_t *s = ((mpc_state_t**)xs)[0];
  mpc_ast_t *a = ((mpc_ast_t**)xs)[1];
  (void)n;
  a = mpc_ast_state(a, *s);
  free(s);
  return a;
}

mpc_parser_t *mpca_state(mpc_parser_t *a) {
  return mpc_and(2, mpcf_state_ast, mpc_state(), a, free);
}

mpc_parser_t *mpca_tag(mpc_parser_t *a, const char *t) {
  return mpc_apply_to(a, (mpc_apply_to_t)mpc_ast_tag, (void*)t);
}

mpc_parser_t *mpca_add_tag(mpc_parser_t *a, const char *t) {
  return mpc_apply_to(a, (mpc_apply_to_t)mpc_ast_add_tag, (void*)t);
}

mpc_parser_t *mpca_root(mpc_parser_t *a) {
  return mpc_apply(a, (mpc_apply_t)mpc_ast_add_root);
}

mpc_parser_t *mpca_not(mpc_parser_t *a) { return mpc_not(a, (mpc_dtor_t)mpc_ast_delete); }
mpc_parser_t *mpca_maybe(mpc_parser_t *a) { return mpc_maybe(a); }
mpc_parser_t *mpca_many(mpc_parser_t *a) { return mpc_many(mpcf_fold_ast, a); }
mpc_parser_t *mpca_many1(mpc_parser_t *a) { return mpc_many1(mpcf_fold_ast, a); }
mpc_parser_t *mpca_count(int n, mpc_parser_t *a) { return mpc_count(n, mpcf_fold_ast, a, (mpc_dtor_t)mpc_ast_delete); }

mpc_parser_t *mpca_or(int n, ...) {

  int i;
  va_list va;

  mpc_parser_t *p = mpc_undefined();

  p->type = MPC_TYPE_OR;
  p->data.or.n = n;
  p->data.or.xs = malloc(sizeof(mpc_parser_t*) * n);

  ((void)((va) = (va_list)&(n)+((sizeof(n) + 3) & ~3)));
  for (i = 0; i < n; i++) {
    p->data.or.xs[i] = (*(mpc_parser_t*  *)(((va)+=((sizeof(mpc_parser_t*) + 3) & ~3))-(((sizeof(mpc_parser_t*) + 3) & ~3))));
  }
  ((void)0);

  return p;

}

mpc_parser_t *mpca_and(int n, ...) {

  int i;
  va_list va;

  mpc_parser_t *p = mpc_undefined();

  p->type = MPC_TYPE_AND;
  p->data.and.n = n;
  p->data.and.f = mpcf_fold_ast;
  p->data.and.xs = malloc(sizeof(mpc_parser_t*) * n);
  p->data.and.dxs = malloc(sizeof(mpc_dtor_t) * (n-1));

  ((void)((va) = (va_list)&(n)+((sizeof(n) + 3) & ~3)));
  for (i = 0; i < n; i++) {
    p->data.and.xs[i] = (*(mpc_parser_t*  *)(((va)+=((sizeof(mpc_parser_t*) + 3) & ~3))-(((sizeof(mpc_parser_t*) + 3) & ~3))));
  }
  for (i = 0; i < (n-1); i++) {
    p->data.and.dxs[i] = (mpc_dtor_t)mpc_ast_delete;
  }
  ((void)0);

  return p;
}

mpc_parser_t *mpca_total(mpc_parser_t *a) { return mpc_total(a, (mpc_dtor_t)mpc_ast_delete); }

/*
** Grammar Parser
*/

/*
** This is another interesting bootstrapping.
**
** Having a general purpose AST type allows
** users to specify the grammar alone and
** let all fold rules be automatically taken
** care of by existing functions.
**
** You don't get to control the type spat
** out but this means you can make a nice
** parser to take in some grammar in nice
** syntax and spit out a parser that works.
**
** The grammar for this looks surprisingly
** like regex but the main difference is that
** it is now whitespace insensitive and the
** base type takes literals of some form.
*/

/*
**
**  ### Grammar Grammar
**
**      <grammar> : (<term> "|" <grammar>) | <term>
**
**      <term> : <factor>*
**
**      <factor> : <base>
**               | <base> "*"
**               | <base> "+"
**               | <base> "?"
**               | <base> "{" <digits> "}"
**
**      <base> : "<" (<digits> | <ident>) ">"
**             | <string_lit>
**             | <char_lit>
**             | <regex_lit> <regex_mode>
**             | "(" <grammar> ")"
*/

typedef struct {
  va_list *va;
  int parsers_num;
  mpc_parser_t **parsers;
  int flags;
} mpca_grammar_st_t;

static mpc_val_t *mpcaf_grammar_or(int n, mpc_val_t **xs) {
  (void) n;
  if (xs[1] == ((void *)0)) { return xs[0]; }
  else { return mpca_or(2, xs[0], xs[1]); }
}

static mpc_val_t *mpcaf_grammar_and(int n, mpc_val_t **xs) {
  int i;
  mpc_parser_t *p = mpc_pass();
  for (i = 0; i < n; i++) {
    if (xs[i] != ((void *)0)) { p = mpca_and(2, p, xs[i]); }
  }
  return p;
}

static mpc_val_t *mpcaf_grammar_repeat(int n, mpc_val_t **xs) {
  int num;
  (void) n;
  if (xs[1] == ((void *)0)) { return xs[0]; }
  switch(((char*)xs[1])[0])
  {
    case '*': { free(xs[1]); return mpca_many(xs[0]); }; break;
    case '+': { free(xs[1]); return mpca_many1(xs[0]); }; break;
    case '?': { free(xs[1]); return mpca_maybe(xs[0]); }; break;
    case '!': { free(xs[1]); return mpca_not(xs[0]); }; break;
    default:
      num = *((int*)xs[1]);
      free(xs[1]);
  }
  return mpca_count(num, xs[0]);
}

static mpc_val_t *mpcaf_grammar_string(mpc_val_t *x, void *s) {
  mpca_grammar_st_t *st = s;
  char *y = mpcf_unescape(x);
  mpc_parser_t *p = (st->flags & MPCA_LANG_WHITESPACE_SENSITIVE) ? mpc_string(y) : mpc_tok(mpc_string(y));
  free(y);
  return mpca_state(mpca_tag(mpc_apply(p, mpcf_str_ast), "string"));
}

static mpc_val_t *mpcaf_grammar_char(mpc_val_t *x, void *s) {
  mpca_grammar_st_t *st = s;
  char *y = mpcf_unescape(x);
  mpc_parser_t *p = (st->flags & MPCA_LANG_WHITESPACE_SENSITIVE) ? mpc_char(y[0]) : mpc_tok(mpc_char(y[0]));
  free(y);
  return mpca_state(mpca_tag(mpc_apply(p, mpcf_str_ast), "char"));
}

static mpc_val_t *mpcaf_fold_regex(int n, mpc_val_t **xs) {
  char *y = xs[0];
  char *m = xs[1];
  mpca_grammar_st_t *st = xs[2];
  mpc_parser_t *p;
  int mode = MPC_RE_DEFAULT;

  (void)n;
  if (strchr(m, 'm')) { mode |= MPC_RE_MULTILINE; }
  if (strchr(m, 's')) { mode |= MPC_RE_DOTALL; }
  y = mpcf_unescape_regex(y);
  p = (st->flags & MPCA_LANG_WHITESPACE_SENSITIVE) ? mpc_re_mode(y, mode) : mpc_tok(mpc_re_mode(y, mode));
  free(y);
  free(m);

  return mpca_state(mpca_tag(mpc_apply(p, mpcf_str_ast), "regex"));
}

/* Should this just use `isdigit` instead? */
static int is_number(const char* s) {
  size_t i;
  for (i = 0; i < strlen(s); i++) { if (!strchr("0123456789", s[i])) { return 0; } }
  return 1;
}

static mpc_parser_t *mpca_grammar_find_parser(char *x, mpca_grammar_st_t *st) {

  int i;
  mpc_parser_t *p;

  /* Case of Number */
  if (is_number(x)) {

    i = strtol(x, ((void *)0), 10);

    while (st->parsers_num <= i) {
      st->parsers_num++;
      st->parsers = realloc(st->parsers, sizeof(mpc_parser_t*) * st->parsers_num);
      st->parsers[st->parsers_num-1] = (*(mpc_parser_t*  *)(((*st->va)+=((sizeof(mpc_parser_t*) + 3) & ~3))-(((sizeof(mpc_parser_t*) + 3) & ~3))));
      if (st->parsers[st->parsers_num-1] == ((void *)0)) {
        return mpc_failf("No Parser in position %i! Only supplied %i Parsers!", i, st->parsers_num);
      }
    }

    return st->parsers[st->parsers_num-1];

  /* Case of Identifier */
  } else {

    /* Search Existing Parsers */
    for (i = 0; i < st->parsers_num; i++) {
      mpc_parser_t *q = st->parsers[i];
      if (q == ((void *)0)) { return mpc_failf("Unknown Parser '%s'!", x); }
      if (q->name && strcmp(q->name, x) == 0) { return q; }
    }

    /* Search New Parsers */
    while (1) {

      p = (*(mpc_parser_t*  *)(((*st->va)+=((sizeof(mpc_parser_t*) + 3) & ~3))-(((sizeof(mpc_parser_t*) + 3) & ~3))));

      st->parsers_num++;
      st->parsers = realloc(st->parsers, sizeof(mpc_parser_t*) * st->parsers_num);
      st->parsers[st->parsers_num-1] = p;

      if (p == ((void *)0) || p->name == ((void *)0)) { return mpc_failf("Unknown Parser '%s'!", x); }
      if (p->name && strcmp(p->name, x) == 0) { return p; }

    }

  }

}

static mpc_val_t *mpcaf_grammar_id(mpc_val_t *x, void *s) {

  mpca_grammar_st_t *st = s;
  mpc_parser_t *p = mpca_grammar_find_parser(x, st);
  free(x);

  if (p->name) {
    return mpca_state(mpca_root(mpca_add_tag(p, p->name)));
  } else {
    return mpca_state(mpca_root(p));
  }
}

mpc_parser_t *mpca_grammar_st(const char *grammar, mpca_grammar_st_t *st) {

  char *err_msg;
  mpc_parser_t *err_out;
  mpc_result_t r;
  mpc_parser_t *GrammarTotal, *Grammar, *Term, *Factor, *Base;

  GrammarTotal = mpc_new("grammar_total");
  Grammar = mpc_new("grammar");
  Term = mpc_new("term");
  Factor = mpc_new("factor");
  Base = mpc_new("base");

  mpc_define(GrammarTotal,
    mpc_predictive(mpc_total(Grammar, mpc_soft_delete))
  );

  mpc_define(Grammar, mpc_and(2, mpcaf_grammar_or,
    Term,
    mpc_maybe(mpc_and(2, mpcf_snd_free, mpc_sym("|"), Grammar, free)),
    mpc_soft_delete
  ));

  mpc_define(Term, mpc_many1(mpcaf_grammar_and, Factor));

  mpc_define(Factor, mpc_and(2, mpcaf_grammar_repeat,
    Base,
      mpc_or(6,
        mpc_sym("*"),
        mpc_sym("+"),
        mpc_sym("?"),
        mpc_sym("!"),
        mpc_tok_brackets(mpc_int(), free),
        mpc_pass()),
    mpc_soft_delete
  ));

  mpc_define(Base, mpc_or(5,
    mpc_apply_to(mpc_tok(mpc_string_lit()), mpcaf_grammar_string, st),
    mpc_apply_to(mpc_tok(mpc_char_lit()),   mpcaf_grammar_char, st),
    mpc_tok(mpc_and(3, mpcaf_fold_regex, mpc_regex_lit(), mpc_many(mpcf_strfold, mpc_oneof("ms")), mpc_lift_val(st), free, free)),
    mpc_apply_to(mpc_tok_braces(mpc_or(2, mpc_digits(), mpc_ident()), free), mpcaf_grammar_id, st),
    mpc_tok_parens(Grammar, mpc_soft_delete)
  ));

  mpc_optimise(GrammarTotal);
  mpc_optimise(Grammar);
  mpc_optimise(Factor);
  mpc_optimise(Term);
  mpc_optimise(Base);

  if(!mpc_parse("<mpc_grammar_compiler>", grammar, GrammarTotal, &r)) {
    err_msg = mpc_err_string(r.error);
    err_out = mpc_failf("Invalid Grammar: %s", err_msg);
    mpc_err_delete(r.error);
    free(err_msg);
    r.output = err_out;
  }

  mpc_cleanup(5, GrammarTotal, Grammar, Term, Factor, Base);

  mpc_optimise(r.output);

  return (st->flags & MPCA_LANG_PREDICTIVE) ? mpc_predictive(r.output) : r.output;

}

mpc_parser_t *mpca_grammar(int flags, const char *grammar, ...) {
  mpca_grammar_st_t st;
  mpc_parser_t *res;
  va_list va;
  ((void)((va) = (va_list)&(grammar)+((sizeof(grammar) + 3) & ~3)));

  st.va = &va;
  st.parsers_num = 0;
  st.parsers = ((void *)0);
  st.flags = flags;

  res = mpca_grammar_st(grammar, &st);
  free(st.parsers);
  ((void)0);
  return res;
}

typedef struct {
  char *ident;
  char *name;
  mpc_parser_t *grammar;
} mpca_stmt_t;

static mpc_val_t *mpca_stmt_afold(int n, mpc_val_t **xs) {
  mpca_stmt_t *stmt = malloc(sizeof(mpca_stmt_t));
  stmt->ident = ((char**)xs)[0];
  stmt->name = ((char**)xs)[1];
  stmt->grammar = ((mpc_parser_t**)xs)[3];
  (void) n;
  free(((char**)xs)[2]);
  free(((char**)xs)[4]);

  return stmt;
}

static mpc_val_t *mpca_stmt_fold(int n, mpc_val_t **xs) {

  int i;
  mpca_stmt_t **stmts = malloc(sizeof(mpca_stmt_t*) * (n+1));

  for (i = 0; i < n; i++) {
    stmts[i] = xs[i];
  }
  stmts[n] = ((void *)0);

  return stmts;
}

static void mpca_stmt_list_delete(mpc_val_t *x) {

  mpca_stmt_t **stmts = x;

  while(*stmts) {
    mpca_stmt_t *stmt = *stmts;
    free(stmt->ident);
    free(stmt->name);
    mpc_soft_delete(stmt->grammar);
    free(stmt);
    stmts++;
  }
  free(x);

}

static mpc_val_t *mpca_stmt_list_apply_to(mpc_val_t *x, void *s) {

  mpca_grammar_st_t *st = s;
  mpca_stmt_t *stmt;
  mpca_stmt_t **stmts = x;
  mpc_parser_t *left;

  while(*stmts) {
    stmt = *stmts;
    left = mpca_grammar_find_parser(stmt->ident, st);
    if (st->flags & MPCA_LANG_PREDICTIVE) { stmt->grammar = mpc_predictive(stmt->grammar); }
    if (stmt->name) { stmt->grammar = mpc_expect(stmt->grammar, stmt->name); }
    mpc_optimise(stmt->grammar);
    mpc_define(left, stmt->grammar);
    free(stmt->ident);
    free(stmt->name);
    free(stmt);
    stmts++;
  }

  free(x);

  return ((void *)0);
}

static mpc_err_t *mpca_lang_st(mpc_input_t *i, mpca_grammar_st_t *st) {

  mpc_result_t r;
  mpc_err_t *e;
  mpc_parser_t *Lang, *Stmt, *Grammar, *Term, *Factor, *Base;

  Lang    = mpc_new("lang");
  Stmt    = mpc_new("stmt");
  Grammar = mpc_new("grammar");
  Term    = mpc_new("term");
  Factor  = mpc_new("factor");
  Base    = mpc_new("base");

  mpc_define(Lang, mpc_apply_to(
    mpc_total(mpc_predictive(mpc_many(mpca_stmt_fold, Stmt)), mpca_stmt_list_delete),
    mpca_stmt_list_apply_to, st
  ));

  mpc_define(Stmt, mpc_and(5, mpca_stmt_afold,
    mpc_tok(mpc_ident()), mpc_maybe(mpc_tok(mpc_string_lit())), mpc_sym(":"), Grammar, mpc_sym(";"),
    free, free, free, mpc_soft_delete
  ));

  mpc_define(Grammar, mpc_and(2, mpcaf_grammar_or,
      Term,
      mpc_maybe(mpc_and(2, mpcf_snd_free, mpc_sym("|"), Grammar, free)),
      mpc_soft_delete
  ));

  mpc_define(Term, mpc_many1(mpcaf_grammar_and, Factor));

  mpc_define(Factor, mpc_and(2, mpcaf_grammar_repeat,
    Base,
      mpc_or(6,
        mpc_sym("*"),
        mpc_sym("+"),
        mpc_sym("?"),
        mpc_sym("!"),
        mpc_tok_brackets(mpc_int(), free),
        mpc_pass()),
    mpc_soft_delete
  ));

  mpc_define(Base, mpc_or(5,
    mpc_apply_to(mpc_tok(mpc_string_lit()), mpcaf_grammar_string, st),
    mpc_apply_to(mpc_tok(mpc_char_lit()),   mpcaf_grammar_char, st),
    mpc_tok(mpc_and(3, mpcaf_fold_regex, mpc_regex_lit(), mpc_many(mpcf_strfold, mpc_oneof("ms")), mpc_lift_val(st), free, free)),
    mpc_apply_to(mpc_tok_braces(mpc_or(2, mpc_digits(), mpc_ident()), free), mpcaf_grammar_id, st),
    mpc_tok_parens(Grammar, mpc_soft_delete)
  ));

  mpc_optimise(Lang);
  mpc_optimise(Stmt);
  mpc_optimise(Grammar);
  mpc_optimise(Term);
  mpc_optimise(Factor);
  mpc_optimise(Base);

  if (!mpc_parse_input(i, Lang, &r)) {
    e = r.error;
  } else {
    e = ((void *)0);
  }

  mpc_cleanup(6, Lang, Stmt, Grammar, Term, Factor, Base);

  return e;
}

mpc_err_t *mpca_lang_file(int flags, FILE *f, ...) {
  mpca_grammar_st_t st;
  mpc_input_t *i;
  mpc_err_t *err;

  va_list va;
  ((void)((va) = (va_list)&(f)+((sizeof(f) + 3) & ~3)));

  st.va = &va;
  st.parsers_num = 0;
  st.parsers = ((void *)0);
  st.flags = flags;

  i = mpc_input_new_file("<mpca_lang_file>", f);
  err = mpca_lang_st(i, &st);
  mpc_input_delete(i);

  free(st.parsers);
  ((void)0);
  return err;
}

mpc_err_t *mpca_lang_pipe(int flags, FILE *p, ...) {
  mpca_grammar_st_t st;
  mpc_input_t *i;
  mpc_err_t *err;

  va_list va;
  ((void)((va) = (va_list)&(p)+((sizeof(p) + 3) & ~3)));

  st.va = &va;
  st.parsers_num = 0;
  st.parsers = ((void *)0);
  st.flags = flags;

  i = mpc_input_new_pipe("<mpca_lang_pipe>", p);
  err = mpca_lang_st(i, &st);
  mpc_input_delete(i);

  free(st.parsers);
  ((void)0);
  return err;
}

mpc_err_t *mpca_lang(int flags, const char *language, ...) {

  mpca_grammar_st_t st;
  mpc_input_t *i;
  mpc_err_t *err;

  va_list va;
  ((void)((va) = (va_list)&(language)+((sizeof(language) + 3) & ~3)));

  st.va = &va;
  st.parsers_num = 0;
  st.parsers = ((void *)0);
  st.flags = flags;

  i = mpc_input_new_string("<mpca_lang>", language);
  err = mpca_lang_st(i, &st);
  mpc_input_delete(i);

  free(st.parsers);
  ((void)0);
  return err;
}

mpc_err_t *mpca_lang_contents(int flags, const char *filename, ...) {

  mpca_grammar_st_t st;
  mpc_input_t *i;
  mpc_err_t *err;

  va_list va;

  FILE *f = fopen(filename, "rb");

  if (f == ((void *)0)) {
    err = mpc_err_file(filename, "Unable to open file!");
    return err;
  }

  ((void)((va) = (va_list)&(filename)+((sizeof(filename) + 3) & ~3)));

  st.va = &va;
  st.parsers_num = 0;
  st.parsers = ((void *)0);
  st.flags = flags;

  i = mpc_input_new_file(filename, f);
  err = mpca_lang_st(i, &st);
  mpc_input_delete(i);

  free(st.parsers);
  ((void)0);

  fclose(f);

  return err;
}

static int mpc_nodecount_unretained(mpc_parser_t* p, int force) {

  int i, total;

  if (p->retained && !force) { return 0; }

  if (p->type == MPC_TYPE_EXPECT) { return 1 + mpc_nodecount_unretained(p->data.expect.x, 0); }

  if (p->type == MPC_TYPE_APPLY)    { return 1 + mpc_nodecount_unretained(p->data.apply.x, 0); }
  if (p->type == MPC_TYPE_APPLY_TO) { return 1 + mpc_nodecount_unretained(p->data.apply_to.x, 0); }
  if (p->type == MPC_TYPE_PREDICT)  { return 1 + mpc_nodecount_unretained(p->data.predict.x, 0); }

  if (p->type == MPC_TYPE_CHECK)    { return 1 + mpc_nodecount_unretained(p->data.check.x, 0); }
  if (p->type == MPC_TYPE_CHECK_WITH) { return 1 + mpc_nodecount_unretained(p->data.check_with.x, 0); }

  if (p->type == MPC_TYPE_NOT)   { return 1 + mpc_nodecount_unretained(p->data.not.x, 0); }
  if (p->type == MPC_TYPE_MAYBE) { return 1 + mpc_nodecount_unretained(p->data.not.x, 0); }

  if (p->type == MPC_TYPE_MANY)  { return 1 + mpc_nodecount_unretained(p->data.repeat.x, 0); }
  if (p->type == MPC_TYPE_MANY1) { return 1 + mpc_nodecount_unretained(p->data.repeat.x, 0); }
  if (p->type == MPC_TYPE_COUNT) { return 1 + mpc_nodecount_unretained(p->data.repeat.x, 0); }

  if (p->type == MPC_TYPE_OR) {
    total = 1;
    for(i = 0; i < p->data.or.n; i++) {
      total += mpc_nodecount_unretained(p->data.or.xs[i], 0);
    }
    return total;
  }

  if (p->type == MPC_TYPE_AND) {
    total = 1;
    for(i = 0; i < p->data.and.n; i++) {
      total += mpc_nodecount_unretained(p->data.and.xs[i], 0);
    }
    return total;
  }

  return 1;

}

void mpc_stats(mpc_parser_t* p) {
  printf("Stats\n");
  printf("=====\n");
  printf("Node Count: %i\n", mpc_nodecount_unretained(p, 1));
}

static void mpc_optimise_unretained(mpc_parser_t *p, int force) {

  int i, n, m;
  mpc_parser_t *t;

  if (p->retained && !force) { return; }

  /* Optimise Subexpressions */

  if (p->type == MPC_TYPE_EXPECT)     { mpc_optimise_unretained(p->data.expect.x, 0); }
  if (p->type == MPC_TYPE_APPLY)      { mpc_optimise_unretained(p->data.apply.x, 0); }
  if (p->type == MPC_TYPE_APPLY_TO)   { mpc_optimise_unretained(p->data.apply_to.x, 0); }
  if (p->type == MPC_TYPE_CHECK)      { mpc_optimise_unretained(p->data.check.x, 0); }
  if (p->type == MPC_TYPE_CHECK_WITH) { mpc_optimise_unretained(p->data.check_with.x, 0); }
  if (p->type == MPC_TYPE_PREDICT)    { mpc_optimise_unretained(p->data.predict.x, 0); }
  if (p->type == MPC_TYPE_NOT)        { mpc_optimise_unretained(p->data.not.x, 0); }
  if (p->type == MPC_TYPE_MAYBE)      { mpc_optimise_unretained(p->data.not.x, 0); }
  if (p->type == MPC_TYPE_MANY)       { mpc_optimise_unretained(p->data.repeat.x, 0); }
  if (p->type == MPC_TYPE_MANY1)      { mpc_optimise_unretained(p->data.repeat.x, 0); }
  if (p->type == MPC_TYPE_COUNT)      { mpc_optimise_unretained(p->data.repeat.x, 0); }

  if (p->type == MPC_TYPE_OR) {
    for(i = 0; i < p->data.or.n; i++) {
      mpc_optimise_unretained(p->data.or.xs[i], 0);
    }
  }

  if (p->type == MPC_TYPE_AND) {
    for(i = 0; i < p->data.and.n; i++) {
      mpc_optimise_unretained(p->data.and.xs[i], 0);
    }
  }

  /* Perform optimisations */

  while (1) {

    /* Merge rhs `or` */
    if (p->type == MPC_TYPE_OR
    &&  p->data.or.xs[p->data.or.n-1]->type == MPC_TYPE_OR
    && !p->data.or.xs[p->data.or.n-1]->retained) {
      t = p->data.or.xs[p->data.or.n-1];
      n = p->data.or.n; m = t->data.or.n;
      p->data.or.n = n + m - 1;
      p->data.or.xs = realloc(p->data.or.xs, sizeof(mpc_parser_t*) * (n + m -1));
      memmove(p->data.or.xs + n - 1, t->data.or.xs, m * sizeof(mpc_parser_t*));
      free(t->data.or.xs); free(t->name); free(t);
      continue;
    }

    /* Merge lhs `or` */
    if (p->type == MPC_TYPE_OR
    &&  p->data.or.xs[0]->type == MPC_TYPE_OR
    && !p->data.or.xs[0]->retained) {
      t = p->data.or.xs[0];
      n = p->data.or.n; m = t->data.or.n;
      p->data.or.n = n + m - 1;
      p->data.or.xs = realloc(p->data.or.xs, sizeof(mpc_parser_t*) * (n + m -1));
      memmove(p->data.or.xs + m, p->data.or.xs + 1, (n - 1) * sizeof(mpc_parser_t*));
      memmove(p->data.or.xs, t->data.or.xs, m * sizeof(mpc_parser_t*));
      free(t->data.or.xs); free(t->name); free(t);
      continue;
    }

    /* Remove ast `pass` */
    if (p->type == MPC_TYPE_AND
    &&  p->data.and.n == 2
    &&  p->data.and.xs[0]->type == MPC_TYPE_PASS
    && !p->data.and.xs[0]->retained
    &&  p->data.and.f == mpcf_fold_ast) {
      t = p->data.and.xs[1];
      mpc_delete(p->data.and.xs[0]);
      free(p->data.and.xs); free(p->data.and.dxs); free(p->name);
      memcpy(p, t, sizeof(mpc_parser_t));
      free(t);
      continue;
    }

    /* Merge ast lhs `and` */
    if (p->type == MPC_TYPE_AND
    &&  p->data.and.f == mpcf_fold_ast
    &&  p->data.and.xs[0]->type == MPC_TYPE_AND
    && !p->data.and.xs[0]->retained
    &&  p->data.and.xs[0]->data.and.f == mpcf_fold_ast) {
      t = p->data.and.xs[0];
      n = p->data.and.n; m = t->data.and.n;
      p->data.and.n = n + m - 1;
      p->data.and.xs = realloc(p->data.and.xs, sizeof(mpc_parser_t*) * (n + m - 1));
      p->data.and.dxs = realloc(p->data.and.dxs, sizeof(mpc_dtor_t) * (n + m - 1 - 1));
      memmove(p->data.and.xs + m, p->data.and.xs + 1, (n - 1) * sizeof(mpc_parser_t*));
      memmove(p->data.and.xs, t->data.and.xs, m * sizeof(mpc_parser_t*));
      for (i = 0; i < p->data.and.n-1; i++) { p->data.and.dxs[i] = (mpc_dtor_t)mpc_ast_delete; }
      free(t->data.and.xs); free(t->data.and.dxs); free(t->name); free(t);
      continue;
    }

    /* Merge ast rhs `and` */
    if (p->type == MPC_TYPE_AND
    &&  p->data.and.f == mpcf_fold_ast
    &&  p->data.and.xs[p->data.and.n-1]->type == MPC_TYPE_AND
    && !p->data.and.xs[p->data.and.n-1]->retained
    &&  p->data.and.xs[p->data.and.n-1]->data.and.f == mpcf_fold_ast) {
      t = p->data.and.xs[p->data.and.n-1];
      n = p->data.and.n; m = t->data.and.n;
      p->data.and.n = n + m - 1;
      p->data.and.xs = realloc(p->data.and.xs, sizeof(mpc_parser_t*) * (n + m -1));
      p->data.and.dxs = realloc(p->data.and.dxs, sizeof(mpc_dtor_t) * (n + m - 1 - 1));
      memmove(p->data.and.xs + n - 1, t->data.and.xs, m * sizeof(mpc_parser_t*));
      for (i = 0; i < p->data.and.n-1; i++) { p->data.and.dxs[i] = (mpc_dtor_t)mpc_ast_delete; }
      free(t->data.and.xs); free(t->data.and.dxs); free(t->name); free(t);
      continue;
    }

    /* Remove re `lift` */
    if (p->type == MPC_TYPE_AND
    &&  p->data.and.n == 2
    &&  p->data.and.xs[0]->type == MPC_TYPE_LIFT
    &&  p->data.and.xs[0]->data.lift.lf == mpcf_ctor_str
    && !p->data.and.xs[0]->retained
    &&  p->data.and.f == mpcf_strfold) {
      t = p->data.and.xs[1];
      mpc_delete(p->data.and.xs[0]);
      free(p->data.and.xs); free(p->data.and.dxs); free(p->name);
      memcpy(p, t, sizeof(mpc_parser_t));
      free(t);
      continue;
    }

    /* Merge re lhs `and` */
    if (p->type == MPC_TYPE_AND
    &&  p->data.and.f == mpcf_strfold
    &&  p->data.and.xs[0]->type == MPC_TYPE_AND
    && !p->data.and.xs[0]->retained
    &&  p->data.and.xs[0]->data.and.f == mpcf_strfold) {
      t = p->data.and.xs[0];
      n = p->data.and.n; m = t->data.and.n;
      p->data.and.n = n + m - 1;
      p->data.and.xs = realloc(p->data.and.xs, sizeof(mpc_parser_t*) * (n + m - 1));
      p->data.and.dxs = realloc(p->data.and.dxs, sizeof(mpc_dtor_t) * (n + m - 1 - 1));
      memmove(p->data.and.xs + m, p->data.and.xs + 1, (n - 1) * sizeof(mpc_parser_t*));
      memmove(p->data.and.xs, t->data.and.xs, m * sizeof(mpc_parser_t*));
      for (i = 0; i < p->data.and.n-1; i++) { p->data.and.dxs[i] = free; }
      free(t->data.and.xs); free(t->data.and.dxs); free(t->name); free(t);
      continue;
    }

    /* Merge re rhs `and` */
    if (p->type == MPC_TYPE_AND
    &&  p->data.and.f == mpcf_strfold
    &&  p->data.and.xs[p->data.and.n-1]->type == MPC_TYPE_AND
    && !p->data.and.xs[p->data.and.n-1]->retained
    &&  p->data.and.xs[p->data.and.n-1]->data.and.f == mpcf_strfold) {
      t = p->data.and.xs[p->data.and.n-1];
      n = p->data.and.n; m = t->data.and.n;
      p->data.and.n = n + m - 1;
      p->data.and.xs = realloc(p->data.and.xs, sizeof(mpc_parser_t*) * (n + m -1));
      p->data.and.dxs = realloc(p->data.and.dxs, sizeof(mpc_dtor_t) * (n + m - 1 - 1));
      memmove(p->data.and.xs + n - 1, t->data.and.xs, m * sizeof(mpc_parser_t*));
      for (i = 0; i < p->data.and.n-1; i++) { p->data.and.dxs[i] = free; }
      free(t->data.and.xs); free(t->data.and.dxs); free(t->name); free(t);
      continue;
    }

    return;

  }

}

void mpc_optimise(mpc_parser_t *p) {
  mpc_optimise_unretained(p, 1);
}

